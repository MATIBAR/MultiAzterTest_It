    Ordenazio algoritmoak 2. GAIA                              ORDENAZIO ALGORITMOAK  ****** 1 SARRERA ****** Ikasgai honetan hainbat ordenazio algoritmo ikusiko dugu. Algoritmo hauek lista bateko elementuak ordena jakin baten arabera berrordenatzen dituzte. Listako elementu bakoitzari identifikadore bat dagokio, giltza izenekoa. Elementu hauek linealki ordenaturik dagoen multzo bateko partaideak direnez gero, bi giltzen arteko alderaketa egitea posiblea da; bietatik handiena zein den edo biak berdinak ote diren determina dezakegu. Berez, giltzaren balio propioa ez zaigu interesatzen, bai ordea beste giltzekiko duen ordena erlatiboa. Listako elementu bakoitzak giltzez at informazio gehiago izan dezake. Ordenazioa egitean giltzaren balioa ez ezik, erregistro berean dagoen beste informazio guztia ere berrordenatuko dugu behar den moduan. Hala eta guztiz ere, ondorengo algoritmoetan giltzari buruz bakarrik mintzatuko gara, eta gainontzeko informazioari buruz ez dugu aipamenik egingo. Zergatik ikasten dira ordenazio algoritmoak? - Ordenazioa maiz egiten denez, algoritmo hauek asko erabiltzen dira. - Problema bera, ordenazioa, algoritmo desberdinek ebatz dezakete. Hauen azterketak baliagarriak gerta dakizkiguke algoritmo bat beste batzuen artean aukeratu nahi dugunean, bai eta emaniko algoritmo bat hobetu nahi denean ere. - Ordenazio algoritmoen kasu txarrenaren eta batezbesteko kasuen kalkulua ez da beste problemetan bezain zaila, lortzen diren bornaketak nahiko onak baitira. Ikasgai honetako algoritmoek goranzko ordena jarraituz ordenatuko dituzte giltzak. Bestalde, Ada programazio-lengoaiatik hurbil idatzi diren algoritmoetan, adibidez, nahiz eta taulak oso-osorik parametro bezala pasa, hauen pasatzeak ez dutela denbora edo memoria-espazio aldetik desabantailarik suposatuko dugu. Hau kontsideratzea zentzuzkoa da gaur egungo konpiladore gehienek erreferentzia bidez pasatzen baitituzte.  ****** 2 BURBUILA ETA AUKERAKETA. ****** ***** 2.1 BURBUILA. ***** Prozesua:   tartekoa dela jabetzean dago gakoa; hots, ordenatu behar diren zenbakien oinarria jakitean. Radix Sort algoritmoak egingo duen prozesua ondorengoa da: lehendabizi, d digitu dituzten n zenbakiak lerroz lerro jarritzen ditu. Ondoren, zenbaki guztien pisu txikieneko digituaren balioarekiko ordenatzen ditu zenbakiak, horretarako egonkorra den algoritmoren bat erabiliz. Prozesu berdina pisu txikieneko digitutik hasi eta pisu handieneko digituraino errepikatuz ordenatzen ditu n zenbakiak. Adibidea: 329 720 720 329 457 355 329 355 657 436 436 436 839 => 457 => 839 => 457 436 657 355 657 720 329 457 720 355 839 657 839  Algoritmoa: type ZENB_D is array ( 1..D) of DIGITUA; type MATRIZEA_N_D is array (1..N) of ZENB_D; procedure BERREDURA is (M: in out MATRIZEA_N_D ; OINARRIA: in INTEGER) is begin for ZUT in 0..OINARRIA-1loop KONTAKETA_MATRIZEA_N_D ( M, ZUT ); end loop; end BERREDURA;  Denbora-ordenaren_analisia: Radix-ek hartzen duen denbora-ordena kontaketa algoritmoak hartzen duen denboraren araberakoa da, non (n+k)=(max(n,k)) dela arrazoitu den. Bestetik, sailkatu behar diren zenbakiak d digituz osaturik daudenez, gure algoritmoan ordena (d n+dk) izango da; hau da, (max(d n,d k)). Baina, k (n) betetzen bada eta normalki sailkatu behar ditugun zenbakien digitu kopurua finkoa denez, d konstantea litzateke eta ondorioz algoritmoaren ordena n-en lineala: (n). k ere konstantea litzateke ordenatu nahiko genituzkeen zenbakien oinarria beti berdina balitz. Hala ere, informatika munduan maiz 2,8, 16 eta 10 erabiltzen ditugu.  1(1) Hemendik aurrerantzean lg n laburtzapena erabiliko dugu 2 oinarriarentzat. Hala ere, gogora bedi logaritmo guztiak ordena berekoak direla, oinarri batetik besterako bihurketa konstante bat biderkatuz lortzen baita. 2(2) Jakinik log2n = (ln n)/(ln 2) betetzen dela, eta (ln 2) azken batean konstante bat denez, k = (ln 2)•k' eginik, logaritmoak bi oinarrian erabili ordez logaritmo naturalak erabil ditzakegu frogaketako kalkuluak sinplifikatuz. - 113 -
