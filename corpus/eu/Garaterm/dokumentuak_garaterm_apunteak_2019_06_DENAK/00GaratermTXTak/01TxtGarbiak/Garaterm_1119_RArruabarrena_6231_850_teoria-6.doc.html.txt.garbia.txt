                                  Programazio dinamikoa teknika bidezko algoritmoak 6. GAIA:                    PROGAMAZIO DINAMIKOA BIDEZKO ALGORITMOAK  ****** 1 SARRERA. ****** Goitik beherako diseinua naturala eta indartsua da. Hasieran, problema bere osotasunean aztertzen da eta, ondoren, hau zehazten joan behar da; hau da, konplexutasun handiko arazoa, azpiarazoetan banatzen da. Errekurtsioa erabiliaz, maiz mota bateko arazo handia mota bereko baina tamaina txikiago duten azpiarazoak (instantziak) ebazten gara dezakegu. Adibidez, zatitu eta irabazi teknikak estrategia hau erabiltzen du. Ikusi den bezala teknika honi esker sailkapen algoritmo azkarrak lor ditzakegu. Baina, errekurtsioak murriztapenak ditu: zatitu eta irabazi teknikak azpiarazo bakoitza independenteki ebazten du eta honek askotan alferrikako lana egin arazten du. Programazio dinamikoaren estrategia jarraitzen duen algoritmo batek bitarteko emaitzak biltegiratzen ditu: azpiproblemen emaitzak. Ondoren, tamaina handiagoko instantziak ebazteko aurrez kalkulatutako eta biltegiratutako emaitzak bilatzen eta konbinatzen ditu berriz ere birkalkulatu ordez. Honela, azpiproblemen emaitzak konbinatuz problema beraren baina tamaina handiagoa duten instantzien emaitzak lortzen ditu. Prozesu bera jatorrizko instantziaren emaitza lortu arte errepikatzen du. Hau dela eta, problema bat ebazteko problema beraren azpiproblema asko behin baino gehiagotan ebatzi behar den kasurako programazio dinamikoaren teknika guztiz aproposa gertatzen da. Beraz, programazio dinamikoa goranzko metodo bat da, eta algoritmo jaleen teknika berriz, beheranzko metodo bat. Halere, programazio dinamikoa memoriadun funtzioekin inplementatzen denean, beheranzko diseinua erabiliko da. Hau gaiaren amaieran azalduko dugu. Programazio dinamikoaren teknika maiz optimizazio problematan erabiltzen da. Problema horietan soluzio bat baino gehiago egotea posiblea da. Soluzio bakoitzak balio bat erlazionaturik du eta kalkulatu nahi dena, soluzio guztien artetik soluzio onena, optimoa da.(balio maximoa edo balio minimoa). Soluzio hori, soluzio optimo bat da, soluzio optimo bat baino gehiago izan baititzake problemak. Teknika honen bidez ebatzi daitezkeen   non deskonponsagarria(Z) honela defini dezakegun: A1,...,An(0≤A1,...,AnA1b1+...+Anbn=K)  Algoritmo_berria: function TXANPONAK_ITZULI (BALIOA: in TXANPONAK; KOP: in INTEGER) return INTEGER is N: INTEGER:= BALIOA'LAST; -- BALIOA taularen indizeak 1..N direla suposatuko dugu. Gainera ondorengoa betzen dela suposatuz -- eginik dago kodea: BALIOA(N) KOP  i (1i<N  BALIOA(i)BALIOA(i+1) )  T: TAULA(1,KOP):= (others=>SYSTEM.MAX_INT); procedure  TXANPONAK (K: in INTEGER) is Q: INTEGER; begin for  R in 1 .. N loop if  0< K-BALIOA(R) then -- Txanpona kopurua baino txikiagoa da ifT(K-BALIOA(R))=SYSTEM.MAX_INT then TXANPONAK (K-BALIOA(R)); end if; Q:= 1+ T(K-BALIOA(R)); if 1<Q<T(K) then T(K):=Q; end if;  end if; end loop ; if  T(K)=SYSTEM.MAX_INT then -- K kopurua ez da deskonposagarria eta horregatik ez da -- oraindik K posizioko balio aldatu. -- Desponposaezina: 0 balioaz adierazten dugu. T(K):=0; end if ; end if; return T(K); end TXANPONAK ; begin -- 1..BALIOA(1)-1 kopuruak deskonopasaezinak dira. for Kin1..BALIOA(1)-1 loop T(K) := 0; end loop;  -- Txanpon bakarra behar duten kopuruen hasieraketa for Kin1.. N loop T(BALIOA(K)) := 1; end loop;  -- Balio bereziak nahiz kasu nabarietako balioak dauzka T taulak. ifT(KOP) = SYSTEM.MAX_INT then TXANPONAK(KOP); end if; -- T(KOP) aldagaian jaso ditugu KOP kopurua itzultzeko behar diren txanpon kopuru minimoa. return T(KOP); endTXANPONAK_ITZULI;  Ordenaren_analisia: (Txanpon mota desberdinen kopurua, n, problema desberdinetarako desberdinak izan daitekeela onartuko dugu, ondorioz n ez da zenbaki konstantetzat hartuko. Honek ordenan kalkulatzeko garaian eragina izango du) Aurreko bi adibideetan jarraitutako arrazonamendu berdina erabil dezakegu ere hemen. Ez dira alferrikako dei errekurtsiborik egiten. Taulako posizio bakoitzeko balioa behin bakarrik kalkulatuko da eta KOP gelaska ditugu. I gelaska bateko balioa kalkulatzeko gehienez n gelasken balioak beharko ditugu; hain zuzen, Z gelasken balioak beharko ditugu non Z honen balioa honela defini dezakegun                            Z= Nj( 1≤j≤n KOP-bj>0) Z kasu txarrenen n izango da (non n dauden txanpon mota desberdina den). Orduan, I gelaskako balioa mugatzeko gehienez n gelasketako balioetatik txikiena aukeratuko du eta balio horri 1 gehituko dio. Honen kalkulua n-ren ordenakoa izango da. Beraz, algoritmoaren ordena: T(n,KOP)= O(n*KOP) Memoria-espazio estraren erabilera lineala da KOP-en.                                                                           - 93 -
