                               PROGRAMAZIOAREN_METODOLOGIA                                     5._Gaia              Datu-Mota_Abstraktuen_ekuazio_bidezko_espezifikazioa   5.1._Sarrera_3 5.1.1._Helburua_3 5.1.2._Haskell_3 5.2._Haskell-en_aurredefinituta_dauden_oinarrizko_motak_4 5.2.1._Bool_4 5.2.2._Int_4 5.2.3._Integer_5 5.2.4._Float,_Double_5 5.2.5._Char_5 5.2.6._Oinarrizko_motentzako_erlazio-eragileak_5 5.2.7._Oinarrizko_motentzat_eragiketa_berrien_definizioa_5 5.3._Zerrendak_7 5.3.1._Eragiketa_eraikitzaileak_zerrendentzat_7 5.3.2._Eragiketa_ez-eraikitzaile_batzuk_zerrendentzat_8 5.3.4._Zerrendentzako_eragile_erlazio-eragileak_14 5.3.5._Propietateen_frogapen_formala:_Indukzioa_15 5.3.6._Espresioen_sinplifikazioa_22 5.4._Pilak_23 5.4.1._Eragiketa_eraikitzaileak_pilentzat_23 5.4.2._Eragiketa_ez-eraikitzaile_batzuk_pilentzat_25 5.5._Ilarak_27 5.5.1._Eragiketa_eraikitzaileak_ilara_datu-motarentzat_27 5.5.2._Eragiketa_ez-eraikitzaile_batzuk_ilarentzat_29 5.6._Zuhaitz_bitarrak_31 5.6.1._Eragiketa_eraikitzaileak_zuhaitz_bitarrentzat_34 5.6.2._Eragiketa_ez-eraikitzaile_batzuk_zuhaitz_bitarrentzat_37 5.7._Datu-mota_abstraktuak_nahasian_dituzten_adibideak_43 5.8._Modularitatea_Haskell-en_45 5.8.1._Bi_moduluren_definizioa_aurreko_ataletan_emandako_eragiketak_erabiliz_45 5.9._Oharrak_47 5.9.1._Maiuskula_eta_minuskulen_erabilera_izenetan_47 5.9.2._Azalpenak_ipintzeko_bi_era_47   5.1._Sarrera  5.1.1. Helburua Ekuazio bidezko espezifikazioaren (edo aljebra bidezko espezifikazioaren) teknika erabiliz Datu-Mota Abstraktu berriak (DMA berriak) nola definitzen diren aztertzea da gai honetako helburua.  Datu-mota berri bat definitzeko jarraian aipatzen direnak zehaztu behar dira     * Mota horretako balioak zein diren.     * Mota horretako balioekin buru daitezkeen eragiketak.     * Mota horrentzat definitutako eragiketek betetzen dituzten propietateak.  Adibidez, zenbaki osoei dagokien datu-motaren kasuan, balioak zenbaki osoak beraiek dira (…, -2, -1, 0, 1, 2, 3, …), eragiketak batuketa, kenketa eta abar dira eta eragiketa horien propietateek batuketa trukakorra eta elkarkorra dela, kenketa ez dela trukakorra, biderketa banakorra dela batuketarekiko eta abar esaten digute.  Datu-mota bateko balioak zein diren zehazteko eta balio horien gaineko eragiketak definitzeko gehienetan errekurtsibitatea erabiltzen da eta propietateak frogatzerakoan aldiz tresna garrantzitsuena indukzioa da.  5.1.2. Haskell Haskell programazio-lengoaia funtzioetan oinarritzen da. Beraz, funtzio bidezko programazioa bezala ezagutzen da Haskell (eta bera bezalako beste lengoaia batzuk) erabiliz burutzen den programazioa. Haskell lengoaian funtzio guztiak "garbiak" dira, matematikako zentzuan: funtzioek ez dute albo-ondoriorik eragiten (ezta Sarrera/Irteeraz arduratzen diren funtzioek ere). Hori dela eta, Haskell lengoaia erabiliz eraikitzen diren espresio edo adierazpen denak "gardenak" dira ("aipamen-gardentasuna" bezala ezagutzen den propietatea dute).  Haskell lengoaian programa bat funtzio multzo bat izan ohi da. Funtzio bakoitza era independentean exekuta daiteke eta baita beste funtzio batetik deituz ere (kasu bietan parametro formalen ordez argumentu errealak ipiniz).  Haskell-en web orri ofiziala http://haskell.org da eta bertatik sistema eragile desberdinetarako Haskell plataforma instala daiteke: https://www.haskell.org/ platform/. Bestalde https://www.haskell.org/downloads orrian beste aukera batzuk ere badira. Gainera GHC konpilatzailea ere eskura daiteke http:// www.haskell.org/ghc/ helbidean.  Haskell lengoaiaz programak idazteko, notepad++ erabil daiteke editore bezala. Editore hau http://notepad-plus-plus.org helbidean dago eskuragarri.    5.2._Haskell-en_aurredefinituta_dauden_oinarrizko_motak  5.2.1. Bool     * Balioak: {True, False}     * Eragiketak:           o && (and)           o || (or)           o not (not)     * Propietateak (,  eta  espresio boolearrak izanda):           o  &&    && (&& trukakorra da)           o  ||    || (|| trukakorra da)           o not( && )  (not ) || (not ) (De Morgan-en legea)           o not( || )  (not ) && (not ) (De Morgan-en legea)           o  && ( || )  ( && ) || ( && ) (Banakortasuna)           o  || (&& )  ( || ) && ( || ) (Banakortasuna)           o False ||    (False || eragilearentzat elementu neutroa da)           o False &&   False (False && eragilearentzat elementu nulua da)           o True ||   True (True || eragilearentzat elementu nulua da)           o True &&    (True && eragilearentzat elementu neutroa da)           o …  5.2.2. Int     * Balioak: tarte mugatu bateko zenbaki osoak (minBound, maxBound)     * Eragile aritmetikoak:           o - (zeinu negatiboa)           o + (batuketa)           o – (kenketa)           o * (biderketa)           o ^ (berredura, 2 ^ 3 = 8)           o div (zatiketa osoa; idazteko_bi_era: 16 `div` 3 = 5 edo div 16 3 =             5, eta ` karakterea P letraren ondoan dagoen azentu-marka da)           o mod (zatiketa osoaren hondarra; idazteko_bi_era: 16 `mod` 3 = 1 edo             mod 16 3 = 1, eta ` karakterea P letraren ondoan dagoen azentu-             marka da)     * Propietateak:           o x + y = y + x Trukakortasuna           o x + (y + z) = (x + y) + z Elkarkortasuna           o x * (y + z) = (x * y) + (x * z) Banakortasuna           o 0 + x = x 0 neutroa da batuketarentzat           o 1 * x = x 1 neutroa da biderketarentzat           o 0 * x = 0 0 nulua da biderketarentzat           o …  5.2.3. Integer     * Balioak: zenbaki osoak inolako mugarik gabe     * Eragile aritmetikoak: Int kasukoak     * Propietateak: Int kasukoak   5.2.4. Float, Double     * Balioak: zenbaki errealak     * Eragile aritmetikoak: Ez ditugu erabiliko     * Propietateak: Int kasukoen antzekoak  5.2.5. Char     * Balioak: karaktereak ('a', …, 'z', 'A', …, 'Z', …) 0ren teklaren ondoan       dagoen teklako apostrofoa erabiliz     * Eragileak: Ez ditugu erabiliko     * Propietateak: Ez ditugu aztertuko   5.2.6. Oinarrizko motentzako erlazio-eragileak Jarraian erakusten diren erlazio-eragileak aipatu diren oinarrizko mota denentzat balio dute:     * == (berdin)     * /= (ezberdin)     * > (handiagoa)     * >= (handiagoa edo berdina)     * < (txikiagoa)     * <= (txikiagoa edo berdina)   5.2.7. Oinarrizko motentzat eragiketa berrien definizioa Lehenago azaldu diren eragiketak erabiltzeaz gain eragiketa berriak ere defini eta erabil daitezke. Eragiketak definitzerakoan ekuazio bakoitzari zenbaki bat egokituko diogu geroago ekuazio hori aipatu ahal izateko. Hiru adibide emango dira jarraian:      * bikoitia: zenbaki oso bat emanda, True itzuliko du bikoitia baldin bada       eta False bakoitia baldin bada.  Eragiketaren mota: bikoitia:: (Int) -> Bool Eragiketa definitzen duen ekuazioa: bikoitia(x) = (x `mod` 2) == 0 (1)  bikoitia funtzioak x balioarentzat x_`mod`_2 eta 0 alderatzearen balioa itzuliko duela adierazten da ekuazio horren bidez (konparazioaren emaitza True edo False izango da).  Eragiketa bera definitzeko beste_aukera_bat honako hau izango litzateke: bikoitia(x) | (x `mod` 2) == 0 = True (1) | otherwise = False (2)  Definizio hori honela ulertu beharko genuke: x `mod` 2 eta 0 berdinak badira True itzuli eta bestela False itzuli.      * bakoitia: zenbaki oso bat emanda, True itzuliko du zenbaki hori bakoitia       bada eta False itzuliko du zenbaki hori bikoitia bada.  Eragiketaren mota: bakoitia:: (Int) -> Bool Eragiketa definitzen duen ekuazioa: bakoitia(x) = not(bikoitia(x))(1)  Kasu honetan, x zenbaki oso bat emanda, bakoitia funtzioak x zenbaki horrentzat itzuliko duena bikoitia funtzioak x zenbaki horrentzat itzuliko lukeenaren aurkakoa dela adierazten da. Beraz, hasteko bikoitia funtzioak x balioarentzat itzultzen duena kalkulatuko da eta gero balio horren aurkakoa hartuko da not eragilearen bidez.  Adibide honetan ikusten den bezala, aurretik definituta dauden funtzioak ere erabil daitezke funtzio berri bat definitzerakoan.      * hand3: hiru zenbaki oso emanda handiena itzuliko du  Eragiketaren mota: hand3:: (Int, Int, Int) -> Int Eragiketa definitzen duten ekuazioak: hand3(x, y, z) | x >= y && x >= z = x (1) | y > x && y >= z = y (2) | otherwise = z (3)  Definizio hori honela ulertu beharko genuke: x >= y && x >= z betetzen bada, orduan x balioa itzuli, bestela y > x && y >= z betetzen bada, orduan y itzuli eta bestela z itzuli.  Adibide honetan bezala baldintza-zerrenda bat agertzen denean, baldintzak goitik behera aztertuko dira Haskell-en eta betetzen den lehenengo baldintzaren kasuari dagokion emaitza itzuliko da.     5.3._Zerrendak Zerrendak honako era honetan adierazten dira:   eta : eragile eraikitzaileak eta ++ eragilea aurredefinituta daude Haskell- en.    5.9. Oharrak  5.9.1. Maiuskula eta minuskulen erabilera izenetan  Maiuskulak eta minuskulak ondo erabiltzeko honako arau hauek jarraitu behar dira:      * Datu_moten_izenak_maiuskulaz hasten dira: Int, Bool, Char, …      * Moten_ordez_ipintzen_diren_aldagaien_izenak_minuskulaz hasten dira: t.      * True eta False konstanteak maiuskulaz hasten dira.      * Eraikitzaileak ez diren beste eragile denak eta aldagaien izenak       minuskulaz hasten dira (maiuskulak erdian ipintzea egon arren): bikoitia,       bakoitia, leh, hond, badago, luzera, x, s, r, p, q, zatb, kenduLuz,       kenduLuzBik, …   5.9.2. Azalpenak ipintzeko bi era  Haskell-ez idatzitako programetan azalpenak ipini nahi izanez gero, bi aukera daude:      * -- erabiliz:  -- sinboloen atzetik lerroa bukatu arte datorren dena azalpena izango da.  Adibidea:  --Hau azalpen bat da eta lerroa bukatzen denean bukatuko da azalpena       * {- eta -} erabiliz:  {- eta -} sinboloen artean doan dena azalpena da. Lerro batetik bestera pasatuta ere azalpenak aurrera jarraitzen du.  Adibidea:  {- Hau azalpena da baina  lerroz alda gaitezke. -} 1  
