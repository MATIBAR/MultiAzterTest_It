                                ProgramazioarenMetodologia      Kudeaketaren eta Informazio Sistemen Informatikaren Ingeniaritzako Gradua                       Bilboko Ingeniaritza Eskola (UPV/EHU)                     Lengoaia eta Sistema Informatikoak Saila                                      1. maila                                       6._Gaia                       Programa_Errekurtsiboen_eraldaketa                               Burstall-en metodoa:                    errekurtsibotik iteratiborako eraldaketa                                             AURKIBIDEA      6.1. Sarrera eta motibazioa Programazio-problema batzuetan soluzio errazena eta argiena programa errekurtsibo bat izaten da. Esate baterako jarraian aipatzen diren hiru kasuetan hori gertatzen da:      * Definizio matematiko induktiboetan oinarritutako problemak. Adibidez,       faktoriala edo fibonacciaren kasuan bezala:                     faktoriala(0) = 1                    faktoriala(n) = n * faktoriala(n ‚Äì 1)             fibonaccia(0) = 0            fibonaccia(1) = 1            fibonaccia(n) = fibonaccia(n ‚Äì 1) + fibonaccia(n ‚Äì 2)          * Datu-mota errekurtsiboekin zerikusia duten problemak. Ohikoenak diren       datu-mota errekurtsiboak zerrendak, pilak eta zuhaitz bitarrak dira.                                                                                        Eta hortik u aldagaia 0 balioarekin eta v aldagaiaÔÅ¨balioarekin hasieratu beharko ditugula ondoriozta dezakegu:  u := 0; v :=ÔÅ¨;  Hasieraketaren ondoren inbariantea bete egiten dela egiazta daiteke:                           batu_re(ÔÅ¨=u + batu_re(v)=                                     =0 + batu_re(ÔÅ¨)=                                     =batu_re(ÔÅ¨)       * 4. urratsa: Bukaera (while-aren baldintza eta bukaerako esleipena).  Urrats honetan while-ean mantentzeko bete behar den B baldintza eta while- a bukatu ondoren burutu beharko den esleipena zein diren erabaki behar da.      * Iterazioan mantentzeko bete beharreko B baldintza kalkulatzeko bide       errazenaÔÉòB kalkulatzea da:ÔÉòBÔÇ∫"kasu simplea". Baina kasu sinplea       formulatzerakoan aldagai berriak erabili behar dira.  batu_refuntzioan kasu sinpleahutsa_da(ÔÅ¨)da eta 3. urratsean ikusi duguÔÅ¨-ri lotuta doan aldagai berria v dela, berazÔÉòB idazterakoanÔÅ¨erabili beharrean v erabili beharko da:                         ÔÉòBÔÇ∫hutsa_da(v) etaBÔÇ∫ÔÉòhutsa_da(v)      * While-a bukatu ondoren zein esleipen burutu behar den erabakitzeko, hau       da, funtzioak emaitza bezala zein balio itzuliko duen erabakitzeko,       inbariantea hartu eta kasu sinplean gaudela suposatu beharko da (hutsa_da       (v)):                            batu_re(ÔÅ¨=u + batu_re(v)=                                      = u + 0 =                                      = u  Beraz bukaerako esleipena honako hau izango da:                                      r := u;  Gogoratu r aldagaiabatu_refuntzioak itzultzen duen emaitza dela.      * 5. urratsa: While-aren barruko aginduak  Urrats honetan aldagai berriak while-aren barruan nola eguneratu behar diren kalkulatu behar da.  While-aren barruko aginduak kalkulatzekobatu_refuntzioaren kasu errekurtsiboa hartu behar da kontuan.  Iterazioaren barruan joango diren aginduak kalkulatzeko inbariantea hartu, kasu errekurtsiboan gaudela kontsideratu eta hedatze-urrats bat eta tolestatze- urrats bat eman beharko dira. Tolestatze-urratsaren ondoren lortzen den espresioak u eta v aldagaiak nola eguneratu adieraziko digu:  Kasu_errekurtsiboa:ÔÉòhutsa_da(v)  batu_re(ÔÅ¨=u + batu_re(v)= hedatuÔÇÆ  = u + (leh(v) + batu_re(hond(v))) = tolestatuÔÇ=[data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAAHCAYAAACVxmSwAAAACXBIWXMAAA6/            AAAN4QEee52nAAAATElEQVR4nGNhYGD4DwSMDIMYsAy0A4gBLKBQBIJBG5ogt7EgcwabQ0FuAtFgR8IcBxMkF6B7klrmsWATJBfAYgPmOGrFDNUzDi2SDQDGwysYlMmklQAAAABJRU5ErkJggg==][data:image/            png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAJCAYAAAAhFky8AAAACXBIWXMAAA72AAAOaQHHMGoZAAAARklEQVR4nGNhYGD4DwSMDHQCLPSyCG4hyHdAQBdfguyhvw9BBD18CTMf7kOYpcRoRnYYqXpYsAkS61pyQmVg4pBUQEmcAwCJITQa4ib5OAAAAABJRU5ErkJggg==]            (u + leh(v)) + batu_re(hond(v))   u v  Beraz eguneraketa honako esleipen hauen bidez lortuko da:  u :=u + leh(v); v :=hond(v); Esleipenen ordena garrantzitsua da hemen. Izan ere u eguneratzerakoan v ere agertzen da eta ondorioz u aldagaia v baino lehenago eguneratu beharko da. Honako eguneraketa hau ez legoke ondo: [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAjCAYAAADSQImyAAAACXBIWXMAAA6jAAAO2AFmrWykAAAA2UlEQVR4nNWTQQ6DMAwEU8n/ / zJlDyshaIEkdryeA1I4ZbQTa61tO59WFMPldzYcKooYPrw4RKpJ2PHANSpJ2PlHtaQuAqBSUj8FSIWkbgWAelKPAkA5qVcCRHGNLgGgtka3AFF54MMCQCGpKQGQndS0AMlKyk0AZCTlKgBWJ+UuQFYlFSYAViQVKgCikwoXIFFrLBMAEWssFSCeDzxFAHgllSYAPJJKFSAzSUkIgNGkZATASFJSAqRnDUkB8HYNWQHy9MDlBcBdUiUEwL+kygiQc1LlBMAxqS9ep+9IVJB2GgAAAABJRU5ErkJggg==] [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAcCAYAAAAnbDzKAAAACXBIWXMAAA6mAAAOzQEB1RsDAAAAtElEQVR4nNWSwQqFMAwELfj/ v9ynwkKehGhr0mzmkuvMkr33vlVmzxaYpbV2LV8uAOLH57Tzlgo45SEOSgTcV5dQB1jigDLgjTigC9D+3IImYGR1SXrArDhIDRh9F42UgK+rS5YGeIqDJQER4iA8wOPPLcICIleXuAesEgeuAdHvouESsHp1yaeATHEwFcAgDoYDMv7c4nUA0+qSxwBWcWAGsL2LhhrAvrrkL6CSOLgCKoqDHzCgbHBi8xkvAAAAAElFTkSuQmCC]v :=hond(v); u :=u + leh(v);   Eraiki dugun funtzio iteratibo berria honako hau da:  Funtzio iteratiboa ADA* lengoaiaz idatzita: functionbatu_it(ÔÅ¨: [Int])returnr: Intis Hasierako baldintzaÔÇ∫{true}  u: Int; v: [Int];  u := 0; v :=ÔÅ¨; while{INV}ÔÉòhutsa_da(v)loop u :=u + leh(v); v := hond(v); endloop; r = u; Bukaerako baldintzaÔÇ∫{r = batu(ÔÅ¨)}   Bukaerako baldintza horren bidezbatu_itfuntzio iteratiboak lortzen duen r emaitza Haskell-ez idatzitakobatufuntzioak itzuliko lukeenaren berdina dela adierazten dugu.   6.3.2. Elkarkorra ez den eragiketa duten funtzioak  Aurreko adibidean hedatze-urrats bakoitzean zenbaki bat zerrendatik kanpora irtetzen zen eta tolestatze-urratsean zenbaki hori lehendik kanpoan zegoenari batuz zenbaki berri bakar bat gelditzen zitzaigun kanpoan. Hori horrela izan da batuketa elkarkorra delako, hau da, a + (b + c) = (a + b) + c delako:        batu_re([5, 2, 9]) =       hedatuÔÇÆ            = leh([5, 2, 9]) + batu_re(hond([5, 2, 9])) =       tolestatuÔÇÆ         = 5 + batu_re([2, 9]) =       hedatuÔÇÆ            = 5 +(leh([2, 9]) + batu_re(hond([2, 9])))=                            = 5 +(2 + batu_re(hond([2, 9])))=       + elkarkorra delako  =(5 + 2)+ batu_re(hond([2, 9])) =       tolestatuÔÇÆ         = 7 + batu_re([9]) =       hedatuÔÇÆ            = 7 +(leh([9]) + batu_re(hond([9])))=                            = 7 +(9 + batu_re(hond([9])))=       + elkarkorra delako  =(7 + 9)+ batu_re(hond([9])) =       tolestatuÔÇÆ         = 16 + batu_re([]) =       kasu sinpleaÔÇÆ      = 16 + 0 =                            = 16  7.3.2 atalean garatuko dugun adibidean ikusiko dugun bezala, espresioan agertzen den eragiketa elkarkorra ez bada, elkarkorra den eragiketa batez ordezkatu beharko da.  Guk egingo ditugun ariketetan elkarkorra ez den eragile bakarra agertuko da, zerrenda batean elementu berri bat ezkerretik sartzeko balio duen ':' eragilea hain zuzen ere. Eragile hori agertzen denean bi zerrenda elkartzeko balio duen '++' eragileaz ordezkatu beharko da. '++' eragilea elkarkorra da.         ([5, 7] ++ [6, 1, 8]) ++ [9, 3] = [5, 7] ++ ([6, 1, 8] ++ [9, 3])                          baina 5:(7:(9:[]))ÔÇπ(5:7):(9:[])              gainera (5:7):(9:[]) espresioa ez da espresio zuzena.  Osoak diren zenbakiz osatutako zerrenda bat emanda, zerrendako elementu bakoitzari 1 gehituz lortzen den zerrenda itzultzen duengehitufuntzioa kontsideratuko dugu.  Gogoratu: gehitu([5, 2]) = [6, 3].  Funtzio errekurtsiboa Haskell-ez idatzita: gehitu: ([Int])ÔÇÆ[Int] Hasierako_baldintza: {true}  gehitu([]) = []ÔÇ¨kasu sinplea gehitu(x:s) = (x + 1) : gehitu(s)ÔÇ¨kasu errekurtsiboa   Hasierako baldintza 'true' izateak funtzioari sarrerako datu bezala emango zaion zerrendak inolako baldintzarik ez duela bete behar adierazten du.  Jarraian funtzio errekurtsiboa ADA* lengoaiaz idatziko da (ADA* lengoaia ADA eta Haskell-en arteko nahasketa bat da)  Funtzio errekurtsiboa ADA* lengoaiaz: functiongehitu_re(ÔÅ¨: integer)returnr: [Int]is Hasierako baldintza: {true}  ifhutsa_da(ÔÅ¨)thenr := []; elser : = (leh(ÔÅ¨) + 1) :gehitu_re(hond(ÔÅ¨)); endif;  Bukaerako baldintza: {r =gehitu(ÔÅ¨)}  Haskell-en parametroak patroien bidez adierazi daitezke, hau da, zerrenda hutsa daukagunean zer egin behar den adierazteko parametro bezala [] ipini dezakegu eta hutsa ez den zerrenda daukagunean zer egin behar den adierazteko x:s (edo antzeko zerbait) ipini dezakegu. ADA* lengoaian aldiz parametroek beti aldagaiak izan behar dute, ezin dira [] eta x:s erako espresioak ipini parametroen lekuan. Horregatik Haskell-etik ADA*-rako itzulpena egin denean [] eta x:s espresioen ordezÔÅ¨aldagaia ipini da. HorÔÅ¨parametroa zerrenda bat da baina ez dakigu hutsa al den ala ez eta horregatikgehitu_refuntzioanhutsa_dafuntzioa erabili da etaÔÅ¨hutsa ez denean bere elementuak maneiatzekolehetahondfuntzioak erabili dira.  Bukaerako baldintzaren bidezgehitu_refuntzioak itzuliko duen r emaitzagehitufuntzioakÔÅ¨zerrendarentzat itzuliko lukeenaren berdina dela adierazten da. Bukaerako baldintzan hori horrela ipini behar dagehitu_reizeneko funtzioagehitufuntzioaren bertsio errekurtsiboa delako, ez da funtzio bera. Gauza bera egiten dute baina bi funtzio desberdin dira.  Burstall-en metodoko bost urratsak aplikatzerakoan ADA* lengoaiaz idatzitako bertsioa hartuko dugu kontuan, hau da,gehitu_refuntzioa:      * 1. urratsa: Errekurrentzia-erlazioa.  Errekurrentzia-erlazioa kasu errekurtsiboari dagokion funtzioaren definizioa da.                gehitu_re(ÔÅ¨) = (leh(ÔÅ¨) + 1) : gehitu_re(hond(ÔÅ¨))      * 2. urratsa: Inbariantea kalkulatu.  Inbariantea kalkulatzeko errekurrentzia-erlazioa orokortu behar da. Horretarako onena adibide bat garatzea izaten da hedatze eta tolestatze urratsak emanez. Tolestatze-urratsen ondoren gelditzen diren espresioek errekurrentzia-erlazioa nola orokortu erakutsiko digute.  gehitu_re( [6, -1, 8, 0]) = hedatuÔÇÆ  = (leh([6, -1, 8, 0]) + 1) :gehitu_re(hond([6, -1, 8, 0])) = tolestatuÔÇ= 7 :gehitu_re([-1, 8, 0]) = hedatuÔÇÆ  = 7 : ((leh([-1, 8, 0]) + 1) : gehitu_re (hond([-1, 8, 0]))) = tolestatuÔÇ= 7 : (0 : gehitu_re([8, 0])) =            [data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAHCAYAAADnCQYGAAAACXBIWXMAAA7BAAAOeAGNln4cAAAAPklEQVR4nGNhYGD4DwSMDFQELNQ0DG4oyJVAQDXXgsyijUtBBMy1+BTCfEKMOhZkDj7FMMOICSaSvE9suAMAhxchFGvbKkEAAAAASUVORK5CYII=]            ':' eragilea mantenduz ezin dira elkartu  hedatuÔÇÆ  = 7 : (0 : ((leh([8, 0]) + 1) : gehitu_re(hond([8, 0])))) = tolestatuÔÇ= 7 : (0 : (9 : gehitu_re([0]))) =            [data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAHCAYAAABp0096AAAACXBIWXMAAA7HAAAOeAFbz50BAAAAR0lEQVR4nGNhYGD4DwSMDAMEWAbKYrgDQL4HggEJBZC9LMicgXAE2AEwi0GOIEUzuoPJ0c+CLkCKAbBQg1lMTghSnAgpjToAKVEqFgJfqdMAAAAASUVORK5CYII=]            ':' eragilea mantenduz ezin dira elkartu  hedatuÔÇÆ  = 7 : (0 : (9 : ((leh([0]) + 1) : gehitu_re(hond([0]))))) = tolestatuÔÇ=[data:image/            png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAHCAYAAABOfc6SAAAACXBIWXMAAA6yAAANzwGp4odVAAAAUElEQVR4nGNhYGD4DwSMDEMUsAy0AygFLKDQB4IhGQsgd7Mgc4aSJ0DuBdFgD8AcDhOkBsAWGLQwnwWbIDUAzLGwJEpt82GAZpkY5nBaJ00AAAIvGCanWDcAAAAASUVORK5CYII=]            7 : (0 : (9 : (1 : gehitu_re([])))) =             ':' eragilea mantenduz ezin dira elkartu  kasu       =7 : (0 : (9 : (1 : []))) = sinpleaÔÇÆ = [7, 0, 9, 1]  ':' eragilea elkarkorra ez denez, bateratze-urratsetan lortu diren espresioek egitura desberdina dute eta ez dute orokorpenik onartzen, ezin direlako elementuak elkartu. Soluzioa ':' eragilearen ordez '++' eragilea erabiltzea da. Beraz, ':' eragilea agertzen denean '++' eragileaz ordezkatuko dugutolestatze- urratsa_ematerakoan:  gehitu_re([6, -1, 8, 0]) = hedatuÔÇÆ                  = (leh([6, -1, 8, 0]) + 1) :gehitu_re(hond([6, -1, tolestatuÔÇÆ               8, 0])) =                            = [7] ++gehitu_re([-1, 8, 0]) = hedatuÔÇÆ                  = [7] ++((leh([-1, 8, 0]) + 1) : gehitu_re(hond([-1, tolestatuÔÇÆ               8, 0])))=                            = [7, 0] ++gehitu_re([8, 0]) = hedatuÔÇÆ                  = [7, 0] ++((leh([8, 0]) + 1) : gehitu_re(hond([8, tolestatuÔÇÆ               0])))=                            = [7, 0, 9] ++gehitu_re([0]) = hedatuÔÇÆ                  = [7, 0, 9] ++ ((leh([0]) + 1) :gehitu_re(hond( tolestatuÔÇÆ               [0]))) =                            = [7, 0, 9, 1] ++gehitu_re([]) = kasu sinpleaÔÇÆ            =[7, 0, 9, 1] ++ [] =                            = [7, 0, 9, 1]  Hedatze-urratseangehitu_refuntzioa bere definizio errekurtsiboa jarraituz ordezkatu behar da.  Tolestatze-urratseanespresioa sinplifikatu egin behar da ahal diren eragiketak burutuz.  Adibide honetan tolestatze-urratsetan ':' kendu eta bere ordez '++' erabili da.  Garatu dugun adibidean tolestatze-urrats bakoitzaren ondoren zerrenda bat etagehitu_refuntzioari egindako dei bat elkartzen dira '++' eragilearen bidez. Eta gainera funtzioak argumentu bezala beste zerrenda bat du.  Orain errekurrentzia-erlazioa orokortu behar da. Errekurrentzia-erlazioa orokortzeko tolestatze-urratsen ondoren lortutako espresioak hartu behar dira kontuan. Tolestatze-urratsen ondoren lortutako espresio horietanaldatuz doazen elementuak aldagai berriez ordezkatubehar dira. Gure adibidean bai kanpoko zerrenda eta bai barrukoa aldatuz doaz.                          = [7, 0] ++ gehitu_re([8, 0]) =                                  [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAHCAYAAADnCQYGAAAACXBIWXMAAA7BAAAOeAGNln4cAAAAPklEQVR4nGNhYGD4DwSMDFQELNQ0DG4oyJVAQDXXgsyijUtBBMy1+BTCfEKMOhZkDj7FMMOICSaSvE9suAMAhxchFGvbKkEAAAAASUVORK5CYII=]                                  [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAHCAYAAADnCQYGAAAACXBIWXMAAA7BAAAOeAGNln4cAAAAPklEQVR4nGNhYGD4DwSMDFQELNQ0DG4oyJVAQDXXgsyijUtBBMy1+BTCfEKMOhZkDj7FMMOICSaSvE9suAMAhxchFGvbKkEAAAAASUVORK5CYII=]  u v Iterazioareninbarianteahonako hau izango da:                         gehitu_re(ÔÅ¨) = u ++ gehitu_re(v)  Garrantzitsua da inbariantea errekurrentzia-erlazioaren orokorpen bat dela ikustea:                 gehitu_re(ÔÅ¨) = (leh(ÔÅ¨) + 1) : gehitu_re (hond(ÔÅ¨))                                  [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAACMAAAAICAYAAABzskasAAAACXBIWXMAAA7tAAAOrAEYrLtKAAAAUElEQVR4nGNhYGD4DwSMDIMAsAy0A5ABCyhUgGDAQwfkBhZkzkA7COwYmCNADiLVAHQPkGMGzBwWdAFSDYGFKMwRlIQuVRMwpdFMsWOomQEAslMwFmIgJ4UAAAAASUVORK5CYII=]                                  [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAACMAAAAHCAYAAACC5PR5AAAACXBIWXMAAA7tAAAOiwHCaQkvAAAAS0lEQVR4nGNhYGD4DwSMDIMAsAy0A5ABCyhUgGDAQwfkBhZkzkA7COwYmCNADiLVAHQPkGMGzBwWdAFSDYGFKMwRlIQuVRIwtaIYAHHLKhY8jQkUAAAAAElFTkSuQmCC]  u v   '(leh(ÔÅ¨) + 1) :'espresioaren ordez 'u ++'ipini da etahond(ÔÅ¨)espresioaren ordezvaldagaia ipini da.      * 3. urratsa: Aldagai berrien hasieraketa.  Inbariantea lortzerakoan agertu diren aldagai berriak nola hasieratu erabaki behar da urrats honetan.  Hasieran, while-ean lehenengo aldiz sartu aurretik, inbarianteak egiazkoa izan behar du eta hori da aldagaiak nola hasieratu erabakitzeko kontuan hartuko duguna. Hasieratu ondoren u eta v aldagaiek honako berdintza hau bete behar dute:                         gehitu_re(ÔÅ¨) = u ++ gehitu_re(v)  Berdintza hori bete dadin u eta v aldagaiak berdintzaren ezkerreko aldean beraien posizio bera okupatzen duten balioekin hasieratu beharko dira. Kasu honetan ezkerreko aldean u aldagaiaren leku berean ezer ez dagoenez eta zerrendak elkartzen ari garenez, [] balioa dagoela suposatu behar da:  [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAHCAYAAAC4NEsKAAAACXBIWXMAAA7PAAAOBgEGIEsUAAAAQElEQVR4nGP5/ /8/ AwgwMjJCGCMMsCBzgIHBOFAOGSjAghzzMPZICggWdIGR5HkQYAF5eKTmfxAYLQNAxEhOBQCzwhoYGT5VGQAAAABJRU5ErkJggg==] [] ++ gehitu_re(ÔÅ¨) = u ++ gehitu_re(v) [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAAE0AAAAICAYAAAC8nHJvAAAACXBIWXMAAA6yAAAPBgGwXj88AAAASUlEQVR4nO3SOwoAMAgD0Aq5/ 5XTDwilS20XEfImBQcJAckmb+CDmY38aJnPVLFCm4FlP1IJ9kVti4Fa9g7eLLUsDvcTOSm0Dx07vhQgpUZvXwAAAABJRU5ErkJggg==]  Eta hortik u aldagaia [] balioarekin eta v aldagaiaÔÅ¨balioarekin hasieratu beharko ditugula ondoriozta dezakegu: u := []; v :=ÔÅ¨;  Hasieraketaren ondoren inbariantea bete egiten dela egiazta daiteke:                        gehitu_re(ÔÅ¨=u ++ gehitu_re(v)=                                    =[] ++ gehitu_re(ÔÅ¨)=                                    =gehitu_re(ÔÅ¨)       * 4. urratsa: Bukaera (while-aren baldintza eta bukaerako esleipena).  Urrats honetan while-ean mantentzeko bete behar den B baldintza eta while- a bukatu ondoren burutu beharko den esleipena zein diren erabaki behar da.      * Iterazioan mantentzeko bete beharreko B baldintza kalkulatzeko bide       errazenaÔÉòB kalkulatzea da:ÔÉòBÔÇ∫"kasu sinplea". Baina kasu sinplea       formulatzerakoan aldagai berriak erabili behar dira:  gehitu_refuntzioan kasu sinpleahutsa_da(ÔÅ¨)da eta 3. urratsean ikusi duguÔÅ¨-ri lotuta doan aldagai berria v dela, berazÔÉòB idazterakoanÔÅ¨erabili beharrean v erabili beharko da                    ÔÉòBÔÇ∫hutsa_da(v) etaBÔÇ∫ÔÉòhutsa_da(v), hau da,                               BÔÇ∫not (hutsa_da(v))      * While-a bukatu ondoren zein esleipen burutu behar den erabakitzeko, hau       da, funtzioak emaitza bezala zein balio itzuliko duen erabakitzeko,       inbariantea hartu eta kasu sinplean gaudela suposatu beharko da (hutsa_da       (v)):                                                  gehitu_re(ÔÅ¨=u ++gehitu_re(v)=                                                              = u ++ []                                                              = u  Beraz bukaerako esleipena honako hau izango da:                                     r := u; Gogoratu r aldagaiagehitu_refuntzioak itzultzen duen emaitza dela.      * 5. urratsa: While-aren barruko aginduak  Urrats honetan aldagai berriak while-aren barruan nola eguneratu behar diren kalkulatu behar da.  While-aren barruko aginduak kalkulatzekogehitu_refuntzioaren kasu errekurtsiboa hartu behar da kontuan.  Iterazioaren barruan joango diren aginduak kalkulatzeko inbariantea hartu, kasu errekurtsiboan gaudela kontsideratu eta hedatze-urrats bat eta tolestatze- urrats bat eman beharko dira. Tolestatze-urratsaren ondoren lortzen den espresioak u eta v aldagaiak nola eguneratu adieraziko digu:  Kasu_errekurtsiboa:ÔÉòhutsa_da(v) gehitu_re(ÔÅ¨=u ++gehitu_re(v)= hedatuÔÇÆ    = u ++ ((leh(v) + 1) : gehitu_re(hond(v))) tolestatuÔÇÆ =[data:image/              png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAKCAYAAACngj4SAAAACXBIWXMAAA7cAAAOzAGydwTlAAAAT0lEQVR4nGNhYGD4DwSMDHQCLPSyaEAsZGRk/              M8CCk4Qg17BCvchvSwFWwizCGQpMZqQHUasHpg+FnQBQpqQLSAnVEhONJTG+dDIFpT4EgDRbDEg7v4KCgAAAABJRU5ErkJggg==] (u ++ [(leh(v) + 1)])              ++ gehitu_re(hond(v)) [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAAEUAAAAKCAYAAADig5OQAAAACXBIWXMAAA7BAAAOkwEwHFQ7AAAAcklEQVR4nO2WUQrAIAxDW+j9r+zmIC4MGf64FNb3JVSwDTEaZtZO3IpBqBvIhru36C7pi3LLTTmFgDkuUeAWFP/ oGp5/OIWF4A07WRFf0cv0+nzlFAw8O++tthtppmBgDnqlGCBF0D5fQHWmpRAFZPkaHE/ kRxwYy3X+AAAAAElFTkSuQmCC]  u v  Beraz eguneraketa honako esleipen hauen bidez lortuko da:  u := u ++ [(leh(v) + 1)]; v :=hond(v);  Esleipenen ordena garrantzitsua da hemen. Izan ere u eguneratzerakoan v ere agertzen da eta ondorioz u aldagaia v baino lehenago eguneratu beharko da. Honako eguneraketa hau ez legoke ondo: [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAjCAYAAADSQImyAAAACXBIWXMAAA6jAAAO2AFmrWykAAAA2UlEQVR4nNWTQQ6DMAwEU8n/ / zJlDyshaIEkdryeA1I4ZbQTa61tO59WFMPldzYcKooYPrw4RKpJ2PHANSpJ2PlHtaQuAqBSUj8FSIWkbgWAelKPAkA5qVcCRHGNLgGgtka3AFF54MMCQCGpKQGQndS0AMlKyk0AZCTlKgBWJ+UuQFYlFSYAViQVKgCikwoXIFFrLBMAEWssFSCeDzxFAHgllSYAPJJKFSAzSUkIgNGkZATASFJSAqRnDUkB8HYNWQHy9MDlBcBdUiUEwL+kygiQc1LlBMAxqS9ep+9IVJB2GgAAAABJRU5ErkJggg==] [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAcCAYAAAAnbDzKAAAACXBIWXMAAA6mAAAOzQEB1RsDAAAAtElEQVR4nNWSwQqFMAwELfj/ v9ynwkKehGhr0mzmkuvMkr33vlVmzxaYpbV2LV8uAOLH57Tzlgo45SEOSgTcV5dQB1jigDLgjTigC9D+3IImYGR1SXrArDhIDRh9F42UgK+rS5YGeIqDJQER4iA8wOPPLcICIleXuAesEgeuAdHvouESsHp1yaeATHEwFcAgDoYDMv7c4nUA0+qSxwBWcWAGsL2LhhrAvrrkL6CSOLgCKoqDHzCgbHBi8xkvAAAAAElFTkSuQmCC]v :=hond(v); u := u ++ [(leh(v) + 1)];   Eraiki dugun funtzio iteratibo berria honako hau da: Funtzio iteratiboa ADA* lengoaiaz: functiongehitu_it(ÔÅ¨: [Int])returnr: [Int]is  Hasierako baldintzaÔÇ∫{true}  u, v: [Int];  u := []; v :=ÔÅ¨; while{INV}nothutsa_da(v)loop u := u ++ [(leh(v) + 1)]; v :=hond(v); endloop; r = u; Bukaerako baldintzaÔÇ∫{r =gehitu(ÔÅ¨)}  Bukaerako baldintza horren bidezgehitu_itfuntzio iteratiboak lortzen duen r emaitza Haskell-ez idatzitakogehitufuntzioak itzuliko lukeenaren berdina dela adierazten dugu.   6.3.3. Kasu sinple bat baino gehiago dituzten funtzioak  Kasu sinple bat baino gehiago egoteak metodoaren 4. urratsean izango du eragina, bai while-aren baldintza kalkulatzerakoan eta baita while-a amaitu ondoren funtzioaren emaitza zein izango den erabakitzerakoan ere.  Zenbaki osoz osatutako bi zerrenda emanda, zerrenda horietako elementuak tartekatuz osatzen den zerrenda berria itzultzen duentartekatuizeneko funtzioa kontsideratuko dugu. Zerrendetako bat bestea baino luzeagoa denean, tartekatu ezinda gelditzen diren elementuak bukaeran ipiniko dira denak jarraian.  Adibidea: [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAHCAYAAADnCQYGAAAACXBIWXMAAA7BAAAOeAGNln4cAAAAQUlEQVR4nGP5/ /8/A7GAkZERqPw/ IyF1LESbSAIg2lCQK0k2lJAmmLeJUccCU0hMWCEbjguAzKJNmJLiSmIAyCwANt4fGnJ2OjIAAAAASUVORK5CYII=] t[data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAiCAYAAAA6RwvCAAAACXBIWXMAAA6UAAAOkAFHcp68AAAAqUlEQVR4nM3QSwrAIAwE0AZy/ yvbWhBE1JrvdDaBbOYxXEq5/hAmolfygAgKqYCKaSAUiscHahlu5XWR/ kIgDTOiIJA+CMwUgsAsIdmYLSQT8wnJwhxBMjDHkGiMCBKJEUOiMCpIBEYN8caYIJ4YM8QL4wLxwLhBrBhXiAXjDtFiQiAaTBhEigmFSDDhkFNMCuQEkwb5wqRCdph0yAoDgcwwMMiIgUJ6zA1ejOhIS4qD6wAAAABJRU5ErkJggg==]artekatu ([2,4], [5, 8, 10, 7]) = [2, 5,4, 8, 10, 7]  tartekatu([5, 8, 10, 7], [2,4]) = [5,2, 8,4, 10, 7] [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAHCAYAAADnCQYGAAAACXBIWXMAAA7BAAAOeAGNln4cAAAAPklEQVR4nGNhYGD4DwSMDFQELNQ0DG4oyJVAQDXXgsyijUtBBMy1+BTCfEKMOhZkDj7FMMOICSaSvE9suAMAhxchFGvbKkEAAAAASUVORK5CYII=] [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAAJCAYAAACvzAXAAAAACXBIWXMAAA61AAAPawF9CBpuAAAAYklEQVR4nM3SUQrAIAwDUAu5/ 5W7KQhxRFakovkTCn2WwN3L7QE/ zKyJX7id4eigwzi3YVEhDGWY+sAJOHjxF6VACj6bzcrQycii2czOq+N/ JJbo1VfgaUiVrLpsRaqs1OUB1JhBFmisGPYAAAAASUVORK5CYII=] zerrenda bat bestea baino luzeagoa izateagatik tartekatzeke gelditu direnak   Ariketetako enuntziatuetan funtzio errekurtsiboa Haskell-ez idatzita etorriko da: Funtzio errekurtsiboa Haskell-ez idatzita: tartekatu: ([Int], [Int])ÔÇÆ[Int] Hasierako_baldintza: {true} tartekatu([], s) = s tartekatu(x : r, s) |hutsa_da(s) = x : r |otherwise = [x] ++ [leh(s)] ++ tartekatu(r, hond(s))  Hasierako baldintza 'true' izateak funtzioari sarrerako datu bezala emango zaizkion zerrendek inolako baldintzarik ez dutela bete behar adierazten du.  Jarraian funtzio errekurtsiboa ADA* lengoaiaz idatziko da (ADA* lengoaia ADA eta Haskell-en arteko nahasketa bat da):  Funtzio errekurtsiboa ADA*-z idatzita: functiontartekatu_re(ÔÅ¨, s: [Int])returnq: [Int]is Hasierako baldintzaÔÇ∫{true} ifhutsa_da(ÔÅ¨)thenq:=s; elsifhutsa_da(s)thenq:=ÔÅ¨; elseq := [leh(ÔÅ¨)] ++ [leh(s)] ++ tartekatu_re(hond(ÔÅ¨), hond(s)); endif; Bukaerako baldintzaÔÇ∫{q = tartekatu(ÔÅ¨, s)}   Haskell-en parametroak patroien bidez adierazi daitezke, hau da, zerrenda hutsa daukagunean zer egin behar den adierazteko parametro bezala [] ipini dezakegu eta hutsa ez den zerrenda daukagunean zer egin behar den adierazteko x:r (edo antzeko zerbait) ipini dezakegu. ADA* lengoaian aldiz parametroek beti aldagaiak izan behar dute, ezin dira [] eta x:r erako espresioak ipini parametroen lekuan. Horregatik Haskell-etik ADA*-rako itzulpena egin denean [] eta x:r espresioen ordezÔÅ¨aldagaia ipini da. HorÔÅ¨parametroa zerrenda bat da baina ez dakigu hutsa al den ala ez eta horregatiktartekatu_refuntzioanhutsa_dafuntzioa erabili da etaÔÅ¨hutsa ez denean bere elementuak maneiatzekolehetahondfuntzioak erabili dira.  Bukaerako baldintzaren bideztartekatu_refuntzioak itzuliko duen q emaitzatartekatufuntzioakÔÅ¨eta s zerrendentzat itzuliko lukeenaren berdina dela adierazten da. Bukaerako baldintzan hori horrela ipini behar datartekatu_reizeneko funtzioatartekatufuntzioaren bertsio errekurtsiboa delako, ez da funtzio bera. Gauza bera egiten dute baina bi funtzio desberdin dira.  Burstall-en metodoko bost urratsak aplikatzerakoan ADA* lengoaiaz idatzitako bertsioa hartuko dugu kontuan, hau da,tartekatu_refuntzioa:      * 1. urratsa: Errekurrentzia-erlazioa.  Errekurrentzia-erlazioa kasu errekurtsiboari dagokion funtzioaren definizioa da.  tartekatu_re(ÔÅ¨,s) = [leh(ÔÅ¨)] ++ [leh(s)]                        ++ tartekatu_re(hond(ÔÅ¨), hond(s))      * 2. urratsa: Inbariantea kalkulatu.  Inbariantea kalkulatzeko errekurrentzia-erlazioa orokortu behar da. Horretarako onena adibide bat garatzea izaten da hedatze eta tolestatze urratsak emanez. Tolestatze-urratsen ondoren gelditzen diren espresioek errekurrentzia-erlazioa nola orokortu erakutsiko digute.        tartekatu_re([8, 0], [3, 9, 4, 7]) =       hedatuÔÇÆ       = leh([8, 0]) ++ leh([3, 9, 4, 7]) ++                       tartekatu_re(hond([8, 0]), hond([3, 9, 4, 7])) =       bateratuÔÇÆ     = [8, 3] ++ tartekatu_re([0], [9, 4, 7]) =       hedatuÔÇÆ       = [8, 3] ++ (leh([0]) ++ leh([9, 4, 7]) ++                       tartekatu_re(hond([0]), hond([9, 4, 7]))) =       bateratuÔÇÆ     = [8, 3, 0, 9] ++ tartekatu_re([], [4, 7]) =       kasu sinpleaÔÇÆ = [8, 3, 0, 9] ++[4, 7] =                       = [8, 3, 0, 9,4, 7]  Hedatze-urratseantartekatu_refuntzioa bere definizio errekurtsiboa jarraituz ordezkatu behar da.  Tolestatze-urratseanespresioa sinplifikatu egin behar da ahal diren eragiketak burutuz.  Garatu dugun adibidean tolestatze-urrats bakoitzaren ondoren zerrenda batez eta argumentu bezala bi zerrenda dituentartekatu_refuntzioaz osatutako espresio bat daukagu.  Tolestatze-urratsen ondoren gelditzen diren espresioetan kanpoko zerrenda etatartekatu_refuntzioaren argumentu diren zerrenda biak aldatuz doazela ikus daiteke.  Orain errekurrentzia-erlazioa orokortu behar da. Errekurrentzia-erlazioa orokortzeko tolestatze-urratsen ondoren lortutako espresioak hartu behar dira kontuan. Tolestatze-urratsen ondoren lortutako espresio horietanaldatuz doazen elementuak aldagai berriez ordezkatubehar dira:        =[data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAHCAYAAABz76/ 0AAAACXBIWXMAAA7eAAAN8wGlJzGLAAAAUElEQVR4nGNhYGD4DwSMDEMEsAy0A0gFLKDQBYIhEcogd7Igcwazo0HuA9FgB8McChOkBGDzNDXNZcEmSAmAOQ6W1KhlLgxQPdPBHEqrJAYAeZsvGESQFCsAAAAASUVORK5CYII=]                                  [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAHCAYAAAA4R3wZAAAACXBIWXMAAA6LAAAOeAEjVVcWAAAANklEQVR4nGNhYGD4DwSMDCQCFlI1wDWCbAMCkm0l30YYA2QruiTMNTg14nImTBM2eYJOxWUoAGYPGhYe+UNAAAAAAElFTkSuQmCC]                                  [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAHCAYAAADnCQYGAAAACXBIWXMAAA7BAAAOiwGyB8xiAAAAPklEQVR4nGNhYGD4DwSMDFQELNQ0DG4oyJVAQDXXgsyijUtBBMy1+BTCfEKMOhZkDj7FMMOICSaSvE9suAMAhxchFGvbKkEAAAAASUVORK5CYII=]                   [8, 3, 0, 9] ++ tartekatu_re([], [4, 7]) =   u v w  Iterazioareninbarianteahonako hau izango da:                   tartekatu_re(ÔÅ¨, s) = u ++ tartekatu_re(v, w)  Garrantzitsua da inbariantea errekurrentzia-erlazioaren orokorpen bat dela ikustea:  u [data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEUAAAANCAYAAAD/ hqMoAAAACXBIWXMAAA7aAAAOggEK1IVzAAAAf0lEQVR4nO2UQQrAMAgEK/j/ L9taEIzY3uouNHMJwctmsoma2cGCiFxxTNA5FB2AERop0RKGttBIYQIuxZvhK7odGZiUJxnxhLrZFK2UCPUlbweOGSrHIgV9Q5WJHN2ZNQ9ZZExSW+l7+EfLQv7Lbil/ bUklxOymNOhuyYq7OAGVClIoZeGpCQAAAABJRU5ErkJggg==]                    tartekatu_re(ÔÅ¨, s) = [leh(ÔÅ¨)] ++ [leh(s)]                        ++ tartekatu_re(hond(ÔÅ¨), hond(s))                                  [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAACMAAAAHCAYAAACC5PR5AAAACXBIWXMAAA7tAAAN8wEnyUSIAAAAS0lEQVR4nGNhYGD4DwSMDIMAsAy0A5ABCyhUgGDAQwfkBhZkzkA7COwYmCNADiLVAHQPkGMGzBwWdAFSDYGFKMwRlIQuVRIwtaIYAHHLKhY8jQkUAAAAAElFTkSuQmCC]                                  [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAHCAYAAAAbHC3MAAAACXBIWXMAAA7cAAAN8wHo75CAAAAARklEQVR4nGNhYGD4DwSMDHQCLPSyCG4hyHdAQBdfguxhQebQw1KwhTCLQJYSownZYcTqgeljQRcgRiMsNMgJFbITDblRAAADWSoWD2CB/                              wAAAABJRU5ErkJggg==]  v w  [leh(ÔÅ¨)] ++ [leh(s)]espresioaren ordezualdagaia ipini da,hond(ÔÅ¨)espresioaren ordezvaldagaia ipini da etahond(s)espresioaren ordezwaldagaia ipini da.      * 3. urratsa: Aldagai berrien hasieraketa.  Inbariantea lortzerakoan agertu diren aldagai berriak nola hasieratu erabaki behar da urrats honetan.  Hasieran, while-ean lehenengo aldiz sartu aurretik inbarianteak egiazkoa izan behar du eta hori da aldagaiak nola hasieratu erabakitzeko kontuan hartuko duguna. Hasieratu ondoren u, v eta w aldagaiek honako berdintza hau bete behar dute:                   tartekatu_re(ÔÅ¨, s) = u ++ tartekatu_re(v, w)   Berdintza hori bete dadin u, v eta w aldagaiak berdintzaren ezkerreko aldean beraien posizio bera okupatzen duten balioekin hasieratu beharko dira. Kasu honetan ezkerreko aldean u aldagaiaren leku berean ezer ez dagoenez eta zerrendak elkartzen ari garenez, [] balioa dagoela imaginatu behar da: [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAAGIAAAAOCAYAAADUk8kvAAAACXBIWXMAAA7LAAAOlQHH3dDbAAAAYklEQVR4nO3YMQrAIBBE0SzM/ a+8iYaAkCKdM5D/KgUL8WOh6u5jqKp7AAutkytKuTbyd/ pegh0IEYIQIQgRghAhCBGCECG0PuSeMe+J/V43gggeGgfP94YfXxwhZghuhd8Js/ MaNAyPYJUAAAAASUVORK5CYII=] [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAAGIAAAAJCAYAAADJlvmXAAAACXBIWXMAAA7LAAAOaQF/ 1H5qAAAAUklEQVR4nO3WOwoAIAwDUAu5/ 5XrD6Hg4NYUzJsqOIihWrh7m8xsF0KBuBihGOsgv8N7i2RQEEUg/ g2n1hOV7+oIhcCBefGamPg0NRWxglBX8HWUpBogRaTgNgAAAABJRU5ErkJggg==] [] ++ tartekatu_re(ÔÅ¨, s) = u ++ tartekatu_re(v, w) [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAAGIAAAANCAYAAABSB7uBAAAACXBIWXMAAA7LAAAOTgGlEcwPAAAAV0lEQVR4nO3TMQoAIRBDUQdy/ yvProJgt90m4H+VgoXwibp7wE/7UFVvky7nZ262QswI7o/cTueFVfiINWTQXgBr8NL3E/ yBECEIEYIQIQgRghAhCBHiARclFDQC1W/EAAAAAElFTkSuQmCC]  Eta hortik u aldagaia [] balioarekin, v aldagaiaÔÅ¨balioarekin eta waldagaias balioarekin hasieratu beharko ditugula ondoriozta dezakegu: u := []; v :=ÔÅ¨; w := s;  Hasieraketaren ondoren inbariantea bete egiten dela egiazta daiteke:                  tartekatu_re(ÔÅ¨,s= u ++ tartekatu_re(v, w) =                                   = [] ++ tartekatu_re(ÔÅ¨,s) =                                   =tartekatu_re(ÔÅ¨,s)      * 4. urratsa: Bukaera (while-aren baldintza eta bukaerako esleipena).  Urrats honetan while-ean mantentzeko bete behar den B baldintza eta while- a bukatu ondoren burutu beharko den esleipena zein diren erabaki behar da.      * Iterazioan mantentzeko bete beharreko B baldintza kalkulatzeko bide       errazenaÔÉòB kalkulatzea da:ÔÉòBÔÇ∫"kasu simplea". Baina orainbi kasu sinple       dituguetaÔÉòBkasu sinpleen disjuntzioaizango da. Gogoratu gainera kasu       sinpleak aldagai berriak erabiliz formulatu behar direla:                           ÔÉòBÔÇ∫hutsa_da(v)ÔÉöhutsa_da(w)                                  eta ondorioz,                          BÔÇ∫ÔÉò(hutsa_da(v)ÔÉöhutsa_da(w))       eta ADA* programazio lengoaia jarraituz hori honela idatziko genuke BÔÇ∫not(hutsa_da(v)orhutsa_da(w)), edo nahi izanez geronot(hutsa_da(v))andnot (hutsa_da(w)) bezala ere idatz daiteke.       * While-a bukatu ondoren zein esleipen burutu behar den erabakitzeko, hau       da, funtzioak emaitza bezala zein balio itzuliko duen erabakitzeko,       inbariantea hartu eta kasu sinplean gaudela suposatu beharko da. Bi kasu       sinple daudenez, kasu bakoitza bere aldetik aztertu beharko da eta kasu       bakoitzean emaitza desberdina izango da. Bi kasu sinple daudenez eta       while-a kasu horietakoren bat gertatzen denean bukatuko denez, while-       a bukatu ondorenifbat ipini beharko da kasu sinpleetako bat       gertatzeagatik bukatzen denean zer egin egin behar den eta beste kasu       sinpleagatik bukatzen denean zer egin behar den zehaztuz:            o Lehenengo_kasu_sinplea: hutsa_da(v)        tartekatu_re(ÔÅ¨,s=u ++ tartekatu_re(v, w)=                         = u ++ w  Beraz kasu honetan burutu beharreko esleipena honako hau izango da:                                  q := u ++ w;  Gogoratuqaldagaiatartekatu_refuntzioak itzultzen duen emaitza dela.             o Bigarren_kasu_sinplea: hutsa_da(w)        tartekatu_re(ÔÅ¨,s=u ++ tartekatu_re(v, w)=                         = u ++ v  Beraz bigarren kasu honetan burutu beharreko esleipena honako hau izango da:                                  q := u ++ v;  Gogoratuqaldagaiatartekatu_refuntzioak itzultzen duen emaitza dela.  Beraz, while-a bukatu ondoren honako if hau ipini beharko da:        ifhutsa_da(v)thenq:= u ++ w;       elseq:= u ++ v;       endif;       * 5. urratsa: While-aren barruko aginduak.  Urrats honetan aldagai berriak while-aren barruan nola eguneratu behar diren kalkulatu behar da.  Bi kasu sinple egoteak ez du eraginik urrats honetan, izan ere while-aren barruko aginduak kalkulatzekotartekatu_refuntzioaren kasu errekurtsiboa hartu behar da kontuan.  Iterazioaren barruan joango diren aginduak kalkulatzeko inbariantea hartu, kasu errekurtsiboan gaudela kontsideratu eta hedatze-urrats bat eta tolestatze- urrats bat eman beharko dira. Tolestatze-urratsaren ondoren lortzen den espresioak u, v eta w aldagaiak nola eguneratu adieraziko digu:  Kasu_errekurtsiboa:ÔÉò(hutsa_da(v)ÔÉöhutsa_da(w))  tartekatu_re(ÔÅ¨, q) =u ++ tartekatu_re(v, w)= hedatuÔÇÆ            = u ++ ([leh(v)] ++ [leh(w)]                      ++ tartekatu_re(hond(v), hond(w))) =                       u tolestatuÔÇÆ         [data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAAAHCAYAAACIuForAAAACXBIWXMAAA6/AAAOeAG8vhKtAAAAYklEQVR4nO2SsQoAIAgFE/z/X7YcHpjQ0BD6oJvElutKzWywISJL26Ta4watFrgFkdliU4T2qJgRF7HzvivH0PES1Zwixn133y000w/                      JdPLNj+5uGg87yTKTO3pbxfAjv2UCvrc8FPMwr0cAAAAASUVORK5CYII=]                      = (u ++ [leh(v)] ++ [leh(w)])                      ++ tartekatu_re(hond(v), hond(w))                      [data:image/                      png;base64,iVBORw0KGgoAAAANSUhEUgAAACMAAAAHCAYAAACC5PR5AAAACXBIWXMAAA7tAAAN8wEnyUSIAAAAS0lEQVR4nGNhYGD4DwSMDIMAsAy0A5ABCyhUgGDAQwfkBhZkzkA7COwYmCNADiLVAHQPkGMGzBwWdAFSDYGFKMwRlIQuVRIwtaIYAHHLKhY8jQkUAAAAAElFTkSuQmCC]                      [data:image/                      png;base64,iVBORw0KGgoAAAANSUhEUgAAACMAAAAHCAYAAACC5PR5AAAACXBIWXMAAA7tAAAN8wEnyUSIAAAAS0lEQVR4nGNhYGD4DwSMDIMAsAy0A5ABCyhUgGDAQwfkBhZkzkA7COwYmCNADiLVAHQPkGMGzBwWdAFSDYGFKMwRlIQuVRIwtaIYAHHLKhY8jQkUAAAAAElFTkSuQmCC]                      v w  Beraz eguneraketa honako esleipen hauen bidez lortuko da:  u :=u ++ [leh(v)] ++ [leh(w)]; v := hond(v); w := hond(w);  Esleipenen ordena garrantzitsua da hemen. Izan ere u eguneratzerakoan v eta w ere agertzen dira eta ondorioz u aldagaia v eta w baino lehenago eguneratu beharko da. Baina v eta w eguneratzerakoan beraien arteko ordena ez da garrantzitsua. Honako eguneraketa hau ondo legoke:  u :=u ++ [leh(v)] ++ [leh(w)]; w := hond(w); v := hond(v);  Baina beste hau ez dago ondo: [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAAD4AAAAqCAYAAADrhujJAAAACXBIWXMAAA7CAAAO4wGZt19jAAAA/ UlEQVR4nOWYQQ7DIAwEqcT/ v5xmDytFadOSAMZezwEJbuPxiVpK2XZeJRkV0jsbLpkGUHFQGAPIIl+Pl0z16/khS/0PcaJe/ 1IcKNf/KU4U6zeJA7X6zeJEpf5tcaBQ/5E4Yf2I8l3iIOrqd4uDiKs/RJxEqj9UHESpP1yceK8/ TRx4rj9VnHisbyIOvNU3Eyde6puLAw/ 1l4iTlfWXioNV9ZeLE+v6bsSBZX1X4sSivktxMLu+W3Eyq757cTCjfghxMrJ+KHEwqn44cdL70RlWHPSsfmhx8HT1w4uTu/ VlxMGd+lLipKW+pDj4V19WnFzVlxcH3+qnECfH+m9duSBlZNPO7AAAAABJRU5ErkJggg==][data: image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAAyCAYAAAAX1CjLAAAACXBIWXMAAA6+AAAO6QEfuHpTAAABDUlEQVR4nN3Wyw7CIBRFUUn6/ 7+MbhMN1mqBcp970g5ZOZO71VpvGdusHyBRKaWmg4F6VFLBXij+08BaFKWA7VEUGgaI7x5FYWFHK7WFhJ2hKBysB0WhYL0oCgMbQVEI2CiK3MNmUOQaNosit7ArKHIJu4oid7AVKHIFW4UiF7B/ x+xs5rCVK7WZwqRQZAaTRJEJTBpF6jANFKnCtFCkBtNEkQpMG0XiMAsUicKsUCQGs0TRcpjE3TfTUpj1Sm3LYJ5QtATmDUWXYR5RdAnmFUXTMM8omoJ5R9EwLAKKhmBRUNQNi4SiLlg0FJ3CIqLoJ8zLMTvbISzqSm1fsAwo+oBlQdEblglFT1g2FN0Bce3EyOBdYfUAAAAASUVORK5CYII=] v := hond(v); u :=u ++ [leh(v)] ++ [leh(w)]; w := hond(w);   Eraiki dugun funtzio iteratibo berria honako hau da:  Funtzio iteratiboa ADA* lengoaiaz: functiontartekatu_it(ÔÅ¨,s: [Int])returnq: [Int]is Hasierako baldintzaÔÇ∫{true}  u, v, w: [Int];  u := []; v :=ÔÅ¨; w :=s; while{INV}not(hutsa_da(v)orhutsa_da(w))loop u :=u ++ [leh(v)] ++ [leh(w)]; v := hond(v); w := hond(w); endloop; ifhutsa_da(v)thenq:= u ++ w; elseq:= u ++ v; endif; Bukaerako baldintzaÔÇ∫{q= tartekatu(ÔÅ¨,s)}   Bukaerako baldintza horren bideztartekatu_itfuntzio iteratiboak lortzen duenqemaitza Haskell-ez idatzitakotartekatufuntzioak itzuliko lukeenaren berdina dela adierazten dugu.     6.3.4. Kasu errekurtsibo bat baino gehiago dituzten funtzioak  Kasu errekurtsibo bat baino gehiago egoteak 1, 2 eta 5 urratsetan izango du eragina, hau da, errekurrentzia-erlazioan, inbariantearen kalkuluan eta while- aren barruko aginduen kalkuluan:      * Kasu errekurtsibo bakoitzeko errekurrentzia-erlazio bat egongo da.     * Inbariante bakarra egongo da baina errekurrentzia-erlazio denen       orokorpena izango da.     * Inbariantean agertuko diren aldagai berriak while-aren barruan nola       eguneratu erabakitzeko, kasu errekurtsibo bakoitza bere aldetik aztertu       beharko da. Eta kasu bakoitzean aldagai berriak era desberdinean       eguneratu beharko direnez, while-aren barruan if bat ipini beharko dugu.  Osoa den x zenbaki bat eta 0rik ez duen zenbaki osozko s zerrenda bat emanda, x-ren zatitzaileak diren s-ko elementu denak hasieran eta x-ren zatitzaileak ez diren s-ko elementuak bukaeran dituen zerrenda berria itzultzen duenbananduizeneko funtzioa kontsideratuko dugu.  Adibidea:  banandu(20, [3, 8,10, 9,4, 7]) = [10,4, 7, 9, 8]  20ren zatitzaile denak hasieran eta ordena mantenduz ageri dira eta 20ren zatitzaileak ez direnak bukaeran eta alderantzizko ordenean ageri dira. Funtzio honek horrela kalkulatuko du emaitza beti.  Funtzio errekurtsiboa Haskell-ez idatzita:  banandu: (Int, [Int])ÔÇÆ[Int] Hasierako_baldintza: {ÔÉòbadago(0, s)} banandu(x, s) |hutsa_da(s) = [] |x mod leh(s) == 0 = [leh(s)] ++ banandu(x, hond(s)) | x mod leh(s) /= 0=banandu(x, hond(s)) ++ [leh(s)]  Kasu honetan Haskell-ez idatzitako funtzioan zerrenda hutsa al den ala ez erabakitzeko [] eta z:r kasuak era esplizitoan bereiztu beharrean zerrendari s deitu zaio eta gerohutsa_da,lehetahondfuntzioak erabili dira kasuak bereizteko eta elementuak eskuratzeko eta maneiatzeko. Ariketetan ere batzuetan patroiak ( [] eta z:r) erabiliko dira eta beste batzuetan aldiz [] eta z:r kasuak zuzenean bereiztu beharrean aldagai bakar bat erabiliko da.  Hasierako baldintza 'ÔÉòbadago(0, s)' izateak funtzioari sarrerako datu bezala emandako zerrendan 0 balioa ez dela agertuko ziurtatzen du.  Jarraian funtzio errekurtsiboa ADA* lengoaiaz idatziko da (ADA* lengoaia ADA eta Haskell-en arteko nahasketa bat da):  Funtzio errekurtsiboa ADA* lengoaiaz: functionbanandu_re(x: Int, s: [Int])returnÔÅ¨: [Int]is Hasierako baldintzaÔÇ∫{ÔÉòbadago(0, s)} ifhutsa_da(s)thenÔÅ¨:= []; elsifxmodleh(s) = 0thenÔÅ¨:= [leh(s)] ++ banandu_re(x, hond(s)); elseÔÅ¨:= banandu_re(x, hond(s)) ++ [leh(s)]; endif; {ÔÅ¨= banandu(x,s)}  Kasu honetan Haskell-ez idatzitako funtziotik ADA* lengoaiaz idatzitako funtzioa lortzeko itzulpena nahiko zuzena izan da Haskell-en ere zerrenda s bezala agertzen zelako eta ez [] eta z:r bezala.  Burstall-en metodoko bost urratsak aplikatzerakoan ADA* lengoaiaz idatzitako bertsioa hartuko dugu kontuan, hau da,banandu_refuntzioa:      * 1. urratsa: Errekurrentzia-erlazioa. Errekurrentzia-erlazioa kasu errekurtsiboari dagokion funtzioaren definizioa da. Funtzio honetan bi kasu errekurtsibo daudenez, bi errekurrentzia-erlazio egongo dira.  xmodleh(s)_=_0_bada:  banandu_re(x,s) = [leh(s)] ++ banandu_re(x, hond(s))  xmodleh(s)ÔÇπ0_bada:  banandu_re(x,s) = banandu_re (x, hond(s)) ++ [leh(s)]      * 2. urratsa: Inbariantea kalkulatu.  Inbariantea kalkulatzeko errekurrentzia-erlazio biak orokortu behar dira. Horretarako onena adibide bat garatzea izaten da hedatze eta tolestatze urratsak emanez. Tolestatze-urratsen ondoren gelditzen diren espresioek errekurrentzia-erlazioak nola orokortu erakutsiko digute.  banandu_re(20, [8,10, 9,4, 7]) = hedatuÔÇÆ     = banandu_re(20, hond([8,10, 9,4, 7]) ++ [leh([8,10, 9,4, 7])] = tolestatuÔÇÆ  = banandu_re(20, [10, 9,4, 7]) ++ [8] = hedatuÔÇÆ     = ([leh([10, 9,4, 7])] ++ banandu_re(20, hond([10, 9,4, 7]))) ++ tolestatuÔÇÆ  [8] =               = [10] ++ banandu_re(20, [9,4, 7]) ++ [8] = hedatuÔÇÆ     = [10] ++ (banandu_re(20, hond([9,4, 7])) ++ [leh([9,4, 7])]) ++ tolestatuÔÇÆ  [8] =               = [10] ++ banandu_re(20, [4, 7]) ++ [9, 8] = hedatuÔÇÆ     = [10] ++ ([leh([4, 7])] ++ banandu_re(20, hond([4, 7]))) ++ [9, tolestatuÔÇÆ  8] =               = [10,4] ++ banandu_re(20, [7]) ++ [9, 8] = hedatuÔÇÆ     = [10,4] ++ (banandu_re(20, hond([7])) ++ [leh([7])]) ++ [9, 8] = tolestatuÔÇÆ  = [10,4] ++ banandu_re(20, []) ++ [7, 9, 8] = kasu sinpleaÔÇ= [10,4] ++ [] ++ [7, 9, 8] =               = [10,4, 7, 9, 8]  Hedatze-urratseanbanandu_refuntzioa bere definizio errekurtsiboa jarraituz ordezkatu behar da.  Tolestatze-urratseanespresioa sinplifikatu egin behar da ahal diren eragiketak burutuz.  Garatu dugun adibidean tolestatze-urrats bakoitzean zerrenda bat, dei errekurtsibo bat eta beste zerrenda bat elkartuz osatutako espresio bat daukagu. Dei errekurtsiboan argumentu bezala zenbaki oso bat eta hirugarren zerrenda bat agertzen dira.  Orain errekurrentzia-erlazioa orokortu behar da. Errekurrentzia-erlazioa orokortzeko tolestatze-urratsen ondoren lortutako espresioak hartu behar dira kontuan. Tolestatze-urratsen ondoren lortutako espresio horietanaldatuz doazen elementuak aldagai berriez ordezkatubehar dira. Gure adibidean bai kanpoko zerrenda biak eta bai dei errekurtsiboko zerrenda aldatuz doaz. Dei errekurtsiboko zenbakia beti berdin mantentzen da eta ondorioz hori ez da ordezkatu behar:                   = [10,4] ++ banandu_re(20, []) ++ [7, 9, 8] = [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAJCAYAAADdA2d2AAAACXBIWXMAAA7BAAAPJwGxd1WwAAAARUlEQVR4nGNhYGD4DwSMDFQELNQ0DG4oyJVAQDXXgsyijUupaRjMx2BDYUGATwMseAipAwG4SwmFKcwwYsJ+4MOU2BQCAOgBIh4SyHE1AAAAAElFTkSuQmCC] [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAACXBIWXMAAA3zAAAOeAH1zMInAAAAL0lEQVR4nGNhYGD4DwSMDFgACzZBuCRIFxBg1Y1fJ4wB0o1VEmYkTAGMj2Esst0AibIWFhn3Ip0AAAAASUVORK5CYII=] [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAACMAAAAJCAYAAAC47pUJAAAACXBIWXMAAA7tAAAPfQGBTSUjAAAAUElEQVR4nGNhYGD4DwSMDIMAsAy0A5ABCyhUgGDAQwfkhsEVMiBioEMHZjc8ZGAOItUgdA9QYgYLNkFSAMxXMEdQErpUTTOURjPFjqFmegMAbAU3GO36trAAAAAASUVORK5CYII=]  u v w  Iterazioareninbarianteahonako hau izango da:                   banandu_re(x, s) = u ++ banandu_re(x, v) ++ w   Garrantzitsua da inbariantea errekurrentzia-erlazio bien orokorpen bat dela ikustea:  xmodleh(s)_=_0:  banandu_re(x,s) = [leh(s)] ++ banandu_re(x, hond(s)) ++ []                                  [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAACMAAAAJCAYAAAC47pUJAAAACXBIWXMAAA7tAAAPJwHBGZD9AAAAUElEQVR4nGNhYGD4DwSMDIMAsAy0A5ABCyhUgGDAQwfkhsEVMiBioEMHZjc8ZGAOItUgdA9QYgYLNkFSAMxXMEdQErpUTTOURjPFjqFmegMAbAU3GO36trAAAAAASUVORK5CYII=]                                  [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAJCAYAAAAhFky8AAAACXBIWXMAAA7cAAAPJwEOP0T1AAAARklEQVR4nGNhYGD4DwSMDHQCLPSyCG4hyHdAQBdfguyhvw9BBD18CTMf7kOYpcRoRnYYqXpYsAkS61pyQmVg4pBUQEmcAwCJITQa4ib5OAAAAABJRU5ErkJggg==]                                  [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAJCAYAAAACTR1pAAAACXBIWXMAAA6LAAAPJwEftHy6AAAAOklEQVR4nGNhYGD4DwSMDCQCFlI1wDWCbAMCkm0l30ZyNIFcyILMQVcA8wZOG3H5D6YJmzzt/                      IjLNQDssxsgSUio8AAAAABJRU5ErkJggg==] u v w xmodleh(s)ÔÇπ0:  banandu_re(x,s) = [] ++ banandu_re(x, hond(s)) ++ [leh(s)] [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAJCAYAAAAhFky8AAAACXBIWXMAAA7cAAAPJwEOP0T1AAAARklEQVR4nGNhYGD4DwSMDHQCLPSyCG4hyHdAQBdfguyhvw9BBD18CTMf7kOYpcRoRnYYqXpYsAkS61pyQmVg4pBUQEmcAwCJITQa4ib5OAAAAABJRU5ErkJggg==] [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAJCAYAAAAhFky8AAAACXBIWXMAAA7cAAAPJwEOP0T1AAAARklEQVR4nGNhYGD4DwSMDHQCLPSyCG4hyHdAQBdfguyhvw9BBD18CTMf7kOYpcRoRnYYqXpYsAkS61pyQmVg4pBUQEmcAwCJITQa4ib5OAAAAABJRU5ErkJggg==] [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAJCAYAAAACTR1pAAAACXBIWXMAAA6LAAAPJwEftHy6AAAAOklEQVR4nGNhYGD4DwSMDCQCFlI1wDWCbAMCkm0l30ZyNIFcyILMQVcA8wZOG3H5D6YJmzzt/ IjLNQDssxsgSUio8AAAAABJRU5ErkJggg==]  u v w  [leh(s)]eta[]espresioen ordezuipini da,hond(s)espresioaren ordezvaldagaia ipini daeta[]eta[leh(s)]espresioen ordezwipini da. Errekurrentzia-erlazioetan ipini diren zerrenda hutsak errekurrentzia-erlazio biek formato bera izan dezaten ipini dira: 'zerrenda' ++ 'dei errekurtsiboa' ++ 'zerrenda'.      * 3. urratsa: Aldagai berrien hasieraketa.  Inbariantea lortzerakoan agertu diren aldagai berriak nola hasieratu erabaki behar da urrats honetan.  Hasieran, while-ean lehenengo aldiz sartu aurretik inbarianteak egiazkoa izan behar du eta hori da aldagaiak nola hasieratu erabakitzeko kontuan hartuko duguna. Hasieratu ondoren u, v eta w aldagaiek honako berdintza hau bete behar dute:                   banandu_re(x, s) = u ++ banandu_re(x, v) ++ w  Berdintza hori bete dadin u, v eta w aldagaiak berdintzaren ezkerreko aldean beraien posizio bera okupatzen duten balioekin hasieratu beharko dira. Kasu honetan ezkerreko aldean u eta w aldagaien leku berean ezer ez dagoenez eta zerrendak elkartzen ari garenez, leku bietan [] balioa dagoela suposatu behar da: [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAAHYAAAAOCAYAAAD61ui9AAAACXBIWXMAAA6+AAAOlQGcMkypAAAAYklEQVR4nO3YMQqAMBAFURf+/ a+8GkUIWNgIkmFelUCKwJAim+7ehqq6FkLIvDki118X0bfyfkQrMiyUYaEMC2VYKMNCGRYq82DiXvufXd/ jxRqVISOk40QeR4pQZ1hfLc8OUVIaNEJeyP0AAAAASUVORK5CYII=] [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAAHYAAAAHCAYAAADd2bl1AAAACXBIWXMAAA6+AAAOBgHGXpVwAAAASUlEQVR4nO3VwQoAIAgD0Ab7/ 1+2LALpHERj76SehCEyIloCsAqTwNqMkPFqEbuL9VJ37YD/x3PgUDUwg/R/ 1eMfK2oG66vV0wGjqRoYbZHJIQAAAABJRU5ErkJggg==] [] ++banandu_re(x, s) ++ [] = u ++banandu_re(x, v) ++ w [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAAHYAAAAKCAYAAABhR6qrAAAACXBIWXMAAA6+AAAPBgHHnP9HAAAAUElEQVR4nO3TOwoAIBADURdy/ yuvH1iwsxHEMK9SsBCGKDMb/KgOETEaZ7z8DO5ZYWfU1x/ BXdovrNaHWKsn1UJZqxedn+BHhDVFWFOENdUBD2UUKFDBJXkAAAAASUVORK5CYII=]  Eta hortik u eta w aldagaiak [] balioarekin eta v aldagaias balioarekin hasieratu beharko ditugula ondoriozta dezakegu:  u := []; v := s; w := [];  Hasieraketaren ondoren inbariantea bete egiten dela egiazta daiteke:                   banandu_re(x,s) =u ++ banandu_re(x, v) ++ w=                                  =[] ++ banandu_re(x,s) ++ []=                                  =banandu_re(x,s)       * 4. urratsa: Bukaera (while-aren baldintza eta bukaerako esleipena).  Urrats honetan while-ean mantentzeko bete behar den B baldintza eta while- a bukatu ondoren burutu beharko den esleipena zein diren erabaki behar da.      * Iterazioan mantentzeko bete beharreko B baldintza kalkulatzerakoan bide       errazenaÔÉòB kalkulatzea da:ÔÉòBÔÇ∫"kasu simplea". Baina kasu sinplea       formulatzerakoan aldagai berriak erabili behar dira:                                  ÔÉòBÔÇ∫hutsa_da(v)                                      eta,                                 BÔÇ∫ÔÉòhutsa_da(v),      * While-a bukatu ondoren zein esleipen burutu behar den erabakitzeko, hau       da, funtzioak emaitza bezala zein balio itzuliko duen erabakitzeko,       inbariantea hartu eta kasu sinplean gaudela suposatu beharko da (hutsa_da       (v)):                  banandu_re (x, s) =u ++ banandu_re(x, v) ++ w=                                   = u ++banandu_re(x, []) ++w =                                   = u++w  Beraz bukaerako esleipena honako hau izango da:                                  ÔÅ¨ := u ++ w; GogoratuÔÅ¨aldagaiabanandu_refuntzioak itzultzen duen emaitza dela.      * 5. urratsa: While-aren barruko aginduak  Urrats honetan aldagai berriak while-aren barruan nola eguneratu behar diren kalkulatu behar da.  While-aren barruko aginduak kalkulatzekobanandu_refuntzioaren kasu errekurtsiboak hartu behar dira kontuan.  Bi kasu errekurtsibo daudenez, bakoitza bere aldetik aztertu beharko da. Hasteko, inbariantea hartu eta lehenengo kasu errekurtsiboan gaudela kontsideratu beharko da eta hedatze-urrats bat eta tolestatze-urrats bat emango dira. Horrela lehenengo kasu errekurtsiboan gaudenean aldagaiak nola eguneratu behar ditugun jakingo dugu. Gero bigarren kasu errekurtsiboan gaudela suposatuz berdina egin beharko da. Bi kasu daudenez eta kasu bakoitzean aldagaiak eguneratzeko era desberdina izango denez while-aren barruanifbat ipini beharko da.            o Lehenengo_kasu_errekurtsiboa: xmodleh(v) = 0        banandu_re   =u ++ banandu_re(x, v) ++ w=       (x, s)       = u ++ ([leh(v)] ++       hedatuÔÇÆ    ++ banandu_re(x, hond(v))) ++ w =                    =[data:image/       tolestatuÔÇÆ png;base64,iVBORw0KGgoAAAANSUhEUgAAADkAAAAJCAYAAACIYoQoAAAACXBIWXMAAA7lAAAPJwEtShKQAAAAYUlEQVR4nGNhYGD4DwSMDMMYsIA8CATD1qMgv7EMtCPoAcCeHK6xCfMTPCZhHoWxB85plAN0f6AkV5ggTBE1Aa6Ao4ddWPMkLWISPXTpmWroVvAgew7Gple2GJDSld6FHACvOEYWEbFLjwAAAABJRU5ErkJggg==]                    [data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAJCAYAAAAhFky8AAAACXBIWXMAAA7xAAAPJwG1DVIdAAAARklEQVR4nGNhYGD4DwSMDHQCLPSyCG4hyHdAQBdfguyhvw9BBD18CTMf7kOYpcRoRnYYqXpYsAkS61pyQmVg4pBUQEmcAwCJITQa4ib5OAAAAABJRU5ErkJggg==][data:image/                    png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAJCAYAAAACTR1pAAAACXBIWXMAAA6zAAAPJwH3nfl6AAAAOklEQVR4nGNhYGD4DwSMDCQCFlI1wDWCbAMCkm0l30ZyNIFcyILMQVcA8wZOG3H5D6YJmzzt/IjLNQDssxsgSUio8AAAAABJRU5ErkJggg==] (u ++ [leh(v)]) ++ banandu_re(x, hond(v)) ++ w                     u v w  Beraz eguneraketa honako esleipen hauen bidez lortuko da:  u :=u ++ [leh(v)]; v := hond(v); w := w;  Esleipenen ordena garrantzitsua da hemen. Izan ere u eguneratzerakoan v ere agertzen da eta ondorioz u aldagaia v baino lehenago eguneratu beharko da. Beste aldetik, w aldagaiaren eguneraketak u eta v-rengan eraginik ez duenez, w edozein unetan egunera daiteke. Honako eguneraketa hau ondo legoke. : w := w; u :=u ++ [leh(v)]; v := hond(v);  Bainabeste eguneraketa hau ez legoke ondo: [data:image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAAD4AAAAqCAYAAADrhujJAAAACXBIWXMAAA7CAAAO4wGZt19jAAAA/ UlEQVR4nOWYQQ7DIAwEqcT/ v5xmDytFadOSAMZezwEJbuPxiVpK2XZeJRkV0jsbLpkGUHFQGAPIIl+Pl0z16/khS/0PcaJe/ 1IcKNf/KU4U6zeJA7X6zeJEpf5tcaBQ/5E4Yf2I8l3iIOrqd4uDiKs/RJxEqj9UHESpP1yceK8/ TRx4rj9VnHisbyIOvNU3Eyde6puLAw/ 1l4iTlfWXioNV9ZeLE+v6bsSBZX1X4sSivktxMLu+W3Eyq757cTCjfghxMrJ+KHEwqn44cdL70RlWHPSsfmhx8HT1w4uTu/ VlxMGd+lLipKW+pDj4V19WnFzVlxcH3+qnECfH+m9duSBlZNPO7AAAAABJRU5ErkJggg==][data: image/ png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAAyCAYAAAAX1CjLAAAACXBIWXMAAA6+AAAO6QEfuHpTAAABDUlEQVR4nN3Wyw7CIBRFUUn6/ 7+MbhMN1mqBcp970g5ZOZO71VpvGdusHyBRKaWmg4F6VFLBXij+08BaFKWA7VEUGgaI7x5FYWFHK7WFhJ2hKBysB0WhYL0oCgMbQVEI2CiK3MNmUOQaNosit7ArKHIJu4oid7AVKHIFW4UiF7B/ x+xs5rCVK7WZwqRQZAaTRJEJTBpF6jANFKnCtFCkBtNEkQpMG0XiMAsUicKsUCQGs0TRcpjE3TfTUpj1Sm3LYJ5QtATmDUWXYR5RdAnmFUXTMM8omoJ5R9EwLAKKhmBRUNQNi4SiLlg0FJ3CIqLoJ8zLMTvbISzqSm1fsAwo+oBlQdEblglFT1g2FN0Bce3EyOBdYfUAAAAASUVORK5CYII=] v := hond(v); u :=u ++ [leh(v)]; w := w;             o Bigarren_kasu_errekurtsiboa:xmodleh(v)ÔÇπ0        banandu_re   =u ++ banandu_re(x, v) ++ w=       (x, s)       = u ++ (banandu_re(x, hond(v)) ++ [leh(v)]) ++ w =       hedatuÔÇÆ                    = u ++ banandu_re(x, hond(v)) ++ ([leh(v)] ++ w)       tolestatuÔÇÆ [data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADcAAAAJCAYAAACWq7SbAAAACXBIWXMAAA68AAAPJwEGy0uvAAAAYUlEQVR4nGNhYGD4DwSMDMMQsIA8BgTDzoMgP7EMtCNoCcCeG26xB/                    MLPOZgHoSxB85p5AN096MkS5ggTBG1AK7AorU9WPMctWMOPUTplULoUqAgJ3l65m26lZbIHqQXAAAN50QalzvWGwAAAABJRU5ErkJggg==][data:image/                    png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAJCAYAAAAhFky8AAAACXBIWXMAAA7xAAAPJwG1DVIdAAAARklEQVR4nGNhYGD4DwSMDHQCLPSyCG4hyHdAQBdfguyhvw9BBD18CTMf7kOYpcRoRnYYqXpYsAkS61pyQmVg4pBUQEmcAwCJITQa4ib5OAAAAABJRU5ErkJggg==]                    [data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAJCAYAAAACTR1pAAAACXBIWXMAAA6zAAAPJwH3nfl6AAAAOklEQVR4nGNhYGD4DwSMDCQCFlI1wDWCbAMCkm0l30ZyNIFcyILMQVcA8wZOG3H5D6YJmzzt/IjLNQDssxsgSUio8AAAAABJRU5ErkJggg==]                    u v w  Beraz bigarren kasu honetan eguneraketa honako esleipen hauen bidez lortuko da:  u :=u; w := [leh(v)] ++ w; v := hond(v);  Esleipenen ordena garrantzitsua da hemen ere, izan ere w aldagaiaren eguneraketan v agertzen denez, w aldagaia v baino lehenago eguneratu behar da. Baina u aldagaiak beste aldagaietan ez duenez eraginik, edozein unetan egunera daiteke.  Bukatzeko, kasu errekurtsibo bietako eguneraketak batera hartuz, honako if agindu hau planteatu behar da:        ifxmodleh(s) = 0thenu := u ++ [leh(v)];       v := hond (v);       w := w;       elseu := u;       w := [leh(v)] ++ w;       v := hond(v);       endif;  If agindu hori w := w eta u := u esleipenak kenduz eta v := hond(v) esleipena if-etik kanpora ateraz sinplifika daiteke, baina guk horrela lagako dugu metodoa jarraituz kasu bakoitzean zer atera den hobeto ikusteko.  Eraiki dugun funtzio iteratibo berria honako hau da: Programa iteratiboa ADA* lengoaiaz: functionbanandu_it(x: Int, s: [Int])returnÔÅ¨: [Int]is Hasierako baldintzaÔÇ∫{ÔÉòbadago(0, s)}  u, v, w: [Int];  u := []; v := s; u := [];  while{INB}nothutsa_da(v)loop ifxmodleh(s) = 0then u := u ++ [leh(v)]; v := hond(v); w := w; else u := u; w := [leh(v)] ++ w; v := hond(v); endif; endloop; ÔÅ¨ := u ++ w; Bukaerako baldintzaÔÇ∫{ÔÅ¨= banandu(x, s)}  Hasierako eta bukerako baldintzen bidez,banandu_itfuntzioak datu bezala zerorik ez duen s zerrenda eta x elementua hartu eta emaitza moduan Haskell-ez idatzitakobanandufuntzioak itzuliko lukeenaren berdina itzuliko duela adierazten da.   6.4. Laburpena eta ondorioak  Gai honetan programa errekurtsiboak iteratibo bihurtzeko balio duen Burstall-en metodoa aurkeztu da eta adibideak garatuz metodo hori lau eratako funtzioetan nola aplikatzen den azaldu da:     1. Oinarrizko funtzio errekurtsiboak (kasu sinple bat eta kasu errekurtsibo       bat).     1. Elkarkorra ez den eragiketa duten funtzio errekurtsiboak.     1. Kasu sinple bat baino gehiago dituzten funtzioak.     1. Kasu errekurtsibo bat baino gehiago dituzten funtzioak.  Gai honetako helburuetako bat errekurtsibitatearen eta iterazioaren arteko erlazioa zein den ulertzea da. Garatu diren lau adibideak begiratuz gero honako ondorio hau atera dezakegu:                Dei errekurtsibo bakoitza while-eko buelta bat da.  Ondorio honek errekurtsioaren eta iterazioaren arteko erlazioa ulertzen hasteko balio digu.                                                                                0  
