     Kapitulua 3 Programen egiaztapena Egindako programa bat zuzena den ala ez jakitea programatzaileon zeregin garrantzitsuenetakoa da. Programa baten garapena ezin da bukatutzat eman zuzena dela egiaztatu aurretik. Hori horrela, programazioaren bilakaeran era askotako teknikak baliatu izan dira zuzentasunaren egiaztapena helburu hartuta. Bi sail nagusitan banatu daitezke teknika horiek: batzuk probatan oinarritzen dira, eta beste batzuk metodo formal-matematikoetan. Probatan oinarritutako teknikek datuen kasuistika zabal bat definitu eta horien arabera aztertzen dute programen portaera. Egiaztapenaren kalitatea diseinatutako proba-bankuaren estalduraren araberakoa da. Hala ere, kontuan hartu behar da E. W. Dijkstra-k esandakoa, hots, probek programak erroreak badituela froga dezakete, ez ordea errore gabea denik. Eredu formal-matematikoetan oinarritutako metodoek konplexutasun formala dute arazo nagusi. Sarri gertatzen da programa egitea bezain konplexua dela programa horren zuzentasuna frogatzea. Kapitulu honetan egiaztapen formalerako teknika batean barneratuko gara. Jakitun gara metodo formal honen aplikazioak konplexutasuna erants diezaiokeela programan garapenari, baina, hala eta guztiz ere, uste dugu programei buruzko arrazonamendu formalean trebatzea oso ekarpen aberatsa dela.  3.1 Programen zuzentasuna eta sistema formalak: Hoare-ren sistema formala Programen zuzentasuna egiaztatu ahal izateko, lehenik eta behin, programen zuzentasuna zer den definitu behar dugu. Horretarako, aurreko kapituluan ikusitako aurre-ondoetako espezifikazioaren kontzeptuan oinarrituko gara. Zuzentasuna espezifikazioari lotuta dago. Programa bat zuzena da, ala ez, beti espezifikazio batekiko. Bi plano bereizten dira: zer espero den programaren exekuzioaz (espezifikazioa), eta benetan zer egiten duen programa horrek. Biak bat badatoz, programa zuzena da; espero zena eta benetan gertatzen dena berdinak ez badira, programa ez da zuzena. Gainera, irakasgai honetan bi zuzentasun mota bereiziko ditugu: zuzentasun partziala eta zuzentasun osoa. Izan bitez S programa eta (Φ,Ψ) espezifikazioa, non Φ aurre-baldintza den eta Ψ post-baldintza. Esango dugu S programa partzialki zuzena dela (Φ,Ψ) espezifikazioarekiko                                      Φ S Ψ baldin eta soilik baldin Φ betetzen den egoera batean hasten den Sren edozein konputazio, bukatzen bada, Ψ betetzen den egoera batean bukatzen bada. Zuzentasun partzialak ez du aintzat hartzen programa bukatzen den ala ez. Bukaeraren alderdia ere tratatzeko, Buka predikatua definituko dugu: Buka(S,Φ) espresioak adierazten du Φ betetzen den egoera batean hasten den Sren edozein konputazio pauso kopuru finituan bukatzen dela. Ohartzekoa da Buka predikatuak bi argumentu dituela: programa bera eta aurreko baldintza. Aurreko baldintza erabakigarria da, izan ere, Φ finkatu ezean ezin baita baieztatu programa bat bukatuko den ala ez. Eta, azkenik, S programa osoki zuzena da (Φ,Ψ) espezifikazioarekiko                                    Φ   f = \i \pr(i=1,n, ) i\s\do5(ψ) Frogapena: •Kasu nabaria:  n ≥0\s\do5(φ)∧n = 0\s\do5(B\s\do4(KN)) f := 1; f = \i \pr(i=1,n, ) i\s\do5(ψ)    1.   2. 1 = \i \pr(i=1,n, ) i       f := 1;     f = \i \pr(i=1,n, ) i (AA)  3. n ≥0  ∧ n = 0    f := 1;   f = \i \pr(i=1,n, ) i 1, 2 eta (ODE)   •Kasu induktiboa. Frogatu beharrekoa:  n ≥0\s\do5(φ)∧n ≠0\s\do5(B\s\do4(KI)) f := fakt(n-1); f := n * f; f = \i \pr                              (i=1,n, ) i\s\do5(ψ) Indukzio-hipotesiaren definizioa:              (I.H.)n-1 ≥0 f := fakt(n-1); f = \i \pr(i=1,n-1, ) i Frogapena:   4. (n≥0∧n≠0)→(n>0)→(n−1≥0)   5. n-1 ≥0       f := fakt(n-1);     f = \i \pr(i=1,n-1, ) i (I.H.)  6. n ≥0  ∧ n ≠0    f := fakt(n-1);     f = \i \pr(i=1,n-1, ) i 4, 5 eta (ODE)  7.  8. n ×f = \i \pr(i=1,n, ) i    f := n*f;     f = \i \pr(i=1,n, ) i (AA)  9. f = \i \pr(i=1,n-1, ) i    f := n*f;      f = \i \pr(i=1,n, ) i 7, 8 eta (ODE)  10. n ≥0  ∧ n ≠0    f := fakt(n-1);    f := n*f;   f = \i \pr(i=1,n, ) i 6, 9 eta (KPE)  •Indukzioaren balidazioa: •Borne-adierazpenaren definizioa: E≡n •Kasu nabarian (n=0): ( n≥0∧n=0)→(n=0)→n∈ •Kasu induktiboan (n≠0): ( n≥0∧n≠0)→(n>0)→(n−1∈∧n>n−1)
