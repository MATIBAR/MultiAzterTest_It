






                            2.2_BEKTOREAKETAJAUZIAK
Lehenengo kapituluan esan den bezala, beraren makina-hizkuntza da konputagailu
batek interpreta dezakeen hizkuntza bakarra. Makina-hizkuntzako aginduak
konputagailuaren arkitektura-ezaugarrien mende daude, eta zerokoen eta batekoen
segiden bidez adierazten dira (kodeketa bitarra). Lehenengo konputagailuetarako
idatzi ziren programak, makina-hizkuntzaz idatzi ziren.
Hala ere, oso astuna da zerokoen eta batekoen segiden bidez programak idaztea;
akats asko egiten dira, eta oso zaila da programa zuzenak sortzea. Arazo horiek
gainditzeko asmoz, ahalmen semantiko handiagoko hizkuntza sinbolikoak sortu
ziren. Hizkuntza horien artean, mihiztadura-hizkuntza da makina-hizkuntzatik
hurbilen dagoena; edukiera semantiko gutxienekoa, alegia. Beste muturrean, goi-
mailako hizkuntzak ditugu. Hizkuntza sinbolikoak erabiliz, programak errazago
idazten dira, baina erabiltzen diren aginduak ezin dira zuzenean konputagailuan
exekutatu. Izan ere, programa horiek itzuli egin behar dira konputagailuak
ulertzen duen hizkuntza bakarrera, eta, itzulpen horretarako, programa bereziak
erabili behar dira: mihiztatzaileak (mihiztadura-hizkuntzetarako) eta
konpiladoreak (goi-mailako hizkuntzetarako).
Goi-mailako hizkuntzak dira programatzaileek gehien erabiltzen dituztenak (ADA,
Cobol, Fortran, C, Lisp, Java, ...). Hizkuntza horietan programatzeko ez da
konputagailuaren arkitektura ezagutu behar, hizkuntzen sintaxia makinaren
baliabideen guztiz independentea baita. Aipatu dugun moduan, goi-mailako
hizkuntzen aginduen edukiera semantikoa makina-hizkuntzako aginduena baino
askoz altuagoa da. Hori dela eta, agindu bakar batekin, makina-hizkuntzako n
agindu ordezkatzen dira (1:n korrespondentzia dago). Beraz, makina-hizkuntzako
aginduekin erkatuta, goi-mailako aginduek lan gehiago egiten dute (eta,
ondorioz, haien exekuzio-denbora altuagoa da).
Lehen aipatu bezala, mihiztadura-hizkuntza da makina-hizkuntzatik hurbilen
dagoen hizkuntza sinbolikoa. Aginduak mnemoteknikoen bidez idazten dira; izan
ere, mihiztadura-hizkuntzaz idatzi dira aurreko kapituluetako programak.
Mihiztadura-hizkuntzako agindu batek makina-hizkuntzako agindu bat ordezkatzen
du, hau da, erlazioa 1:1 da. Horregatik, mihiztadura-hizkuntza zuzenki
erlazionatuta dago konputagailuaren ezaugarriekin. Mihiztadura-hizkuntzako
aginduek konputagailuaren baliabideak —erregistroak, memoria, edo sarrera/
irteerako gailuak— erabiltzen dituzte zuzenean. Beraz, prozesadore bakoitzak
mihiztadura-hizkuntza desberdina, berea, erabiltzen du.
Kapitulu honetan, TXORI mihiztadura-hizkuntza nola erabili behar den azalduko
da, batik bat datu-egiturak (bektoreak eta matrizeak) maneiatzeko eta agindu-
fluxuaren kontrol-egiturak gauzatzeko; hori guztia hainbat adibideren bidez
egingo da.
2.2.1 NOLA ERABILI BEKTOREAK TXORI HIZKUNTZAN
Bektoreak nola erabiltzen diren ikusteko, zenbaki osozko bektoreekin hasiko
gara. Gogoratu: bektore bat datu-zerrenda bat besterik ez da, ondoz ondoko
memoria-posizioetan gordeta. Bi gai landu beharko ditugu. Batetik, bektoreak
nola erazagutu sasiaginduen bidez. Eta, bestetik, bektoreen osagaiak nola
atzitu modu egokienean.
2.2.1.1 Bektoreak erazagutzea
Bi sasiagindu erabili ditugu jadanik aldagaiak erazagutzeko: .word eta .value.
Lehenengoak, tokia erreserbatzen du memorian aldagai baterako. Bigarrenak,
tokia erreserbatzeaz gain, hasiera-balio jakin bat esleitzen dio aldagaiari.
Izan ere, bi sasiagindu horiek erabili behar dira bektoreak ere erazagutzeko.
Bektore-osagaiak ez badira hasieratu behar, nahikoa da .wordsasi-agindua
erabiltzea. Argumentu bakarra onartzen du: memorian erreserbatu behar den
posizio kopurua (balio positiboa, noski). 3.1 irudian, honako adibide hau ageri
da:
C: .word4;
C bektorerako, memoriako ondoz ondoko lau posizio erreserbatzen dira, besterik
gabe.
Bektore-osagaiei hasierako balioak emateko, aldiz, .value sasiagindua erabili
behar da. Hasiera-balioak komen bidez bereizi behar dira; lehenengo balioa
lehenengo osagaiari dagokio, bigarrena bigarrenari, eta abar. 3.1 irudian,
honako adibide hau ageri da:
A: .value6,7,–5,3;
A bektorerako, ondoz ondoko lau posizio erreserbatzen dira, eta 6, 7, –5 eta 3
balioekin hasieratzen dira, hurrenez hurren.
Askotan, hasiera-balio bera esleitu behar zaio ondoz ondoko hainbat osagairi.
Balio horiek guztiak errepikatu beharrean, balio bakar bat eta, parentesien
artean, errepikapen kopurua adieraz daitezke. 3.1 irudian, honako beste adibide
hau ageri da:
B: .value1(4);
B aldagairako, ondoz ondoko lau memoria-posizio erreserbatzen dira, eta
hasiera-balio bera hartzen dute guztiek, 1ekoa.
2.2.1.2 Bektore baten osagaiak atzitzea: helbideratze absolutua eta indexatua
Bektore baten osagaiak homogeneoak direnez, hots, denak luzera eta oinarrizko
mota berekoak, osagaiaren memoria-helbidea, hi,kalkulatzeko, beharrezkoa dugu
jakitea bektorearen hasierako helbidea, h0,eta osagaiaren posizioa bektorean,
i. Informazio hori erabiliz, i osagaiaren helbidea hau izango da: hi=h0+ixlnon
l balioak osagai bakoitzaren luzera adierazten duen, hots zenbat memoria-
posizio okupatzen dituen.
Helbide hori erabiliz, ld edo st aginduak erabil daitezke osagaia hori
atzitzeko (helbideratze-modu absolutua). Hala ere, atzipen mota hori ez da
erosoa, programatzaileak berak kalkulatu behar baitu osagai bakoitzaren
helbidea. Egokia litzateke, beraz, helbideratze-modu eraginkorragoak izatea
bektoreen osagaiak atzitu ahal izateko.
Goi-mailako hizkuntzetan, bektore baten osagai bat adierazteko, bektorearen
izena eta, ondoren, osagaiaren indizea edo posizioa adierazi ohi da. Adibidez,
ADA hizkuntzaz, B bektorearen i osagaia atzitzeko, B(i)idatzi behar da (C
hizkuntzaz, B[i]). TXORI hizkuntzak antzeko aukera bat eskaintzen du, baina,
indizeak adierazteko, erregistro orokor bat erabili behar da. Adibidez,B
bektorearen 3 osagaia atzitzeko, honako hau egin daiteke: 3koa kargatu r1
erregistroan, eta, gero, B[r1]erabili. Osagaiak atzitzeko indize-erregistro bat
erabili behar denez, helbideratze-moduari indexatua deritzo. Hala egiten
denean, beraz, prozesadoreak berak kalkulatuko du bektorearen osagaiaren
helbidea, bektorearen hasiera-helbidea eta osagaiaren posizioa erabiliz (B eta
r1).
Bektore baten osagaiak irakurtzeko eta idazteko, helbideratze indexatua
erabiliz, mihiztadura-hizkuntzako bi agindu hauek ditugu:


▪ ldxrh,A[ri] rh:=M[A+ri]
A izeneko bektorearen osagai bat —ri erregistroak adierazten duena— memoriatik
irakurtzen da, eta rh erregistroan kopiatzen da.


▪ stxrj,A[ri] M[A+ri]:=rj
rj erregistroaren edukia memorian idazten da, A bektorean; ri erregistroak
adierazten duen osagaian, hain zuzen ere.


3.2.1 irudian, agindu horien adibideak ageri dira. Programatxoan, A eta B
bektoreen lehen osagaiak (0 osagaiak) irakurtzen dira —ldxr1,A[r0] eta ldxr2,B
[r0]—, eta, osagai horiek batu ondoren, batura C bektorearen lehen osagaian
idazten da —stxr3,C[r0]—.



.title BEKTOREAK

A: .value 6, 7, -5, 3;
B: .value 1(4);
C: .word 4;

.proc main

ldx r1, A[r0] {r0=0}
ldx r2, B[r0]
add r3, r1, r2
stx r3, C[r0]

retm

.endp main
.end

****** 3.2.1 irudia. C(0) = A(0) + B(0) formularen kalkulua. ******
2.2.2 AGINDUEN FLUXU SEKUENTZIALA HAUSTEKO AGINDUAK: JAUZIAK
Lehen kapituluan aipatu den moduan, programa baten agindu-fluxua sekuentziala
da eskuarki; hots, i aginduaren ondoren, i+1 agindua exekutatzen da. Aginduen
exekuzio-sekuentzia hautsi nahi bada, agindu bereziak erabili behar dira:
jauzi-aginduak. Goi-mailako hizkuntzetan ohikoak diren kontrol-egiturak (if,
for, while, ...) jauzi-aginduen bidez gauzatzen dira behe-mailako hizkuntzetan.
Oro har, jauzi-agindu batek aukera ematen du programaren exekuzio
sekuentzialarekin jarraitzeko, edo programaren beste puntu batera jauzi
egiteko, han dagoen aginduaren exekuzioarekin jarraitzeko. Jauzi-aginduan
bertan adierazten da zein litzatekeen exekutatu beharreko aginduaren helbidea
jauzia beteko balitz; helbide hori etiketa baten bidez identifikatzen da.
Etiketek, beraz, jauzien helburuak markatzen dituzte (nora joan behar den), eta
karaktere alfanumerikoez osatzen dira (lehenengo karakterea, alfabetikoa, eta,
azkena, “:” karakterea).
Jauziak baldintza gabekoak edo baldintzapekoak izan daitezke. Baldintza gabeko
jauzia beti betetzen da. Baldintzapeko jauzia, aldiz, bakarrik gauzatzen da
baldintza jakin bat betetzen bada, eskuarki konparazio baten ondorioz.
Baldintza betetzen ez bada, jauzia ez da gauzatuko, eta exekuzio
sekuentzialarekin jarraituko da.
TXORI hizkuntzaren jauzi-aginduak hauek dira:


▪ jmpetiketa PC:=@etiketa
Baldintza gabeko jauzia da (ingelesez,jump, jauzi). Agindua exekutatu ondoren,
adierazitako etiketa duen aginduarekin jarraituko da (ez ondoz ondoko
aginduarekin, eskuarki egiten den moduan).


▪ beqri,etiketa if(ri=0)
PC
:=@etiketa
(edo bne, bls, ble, bgt, bge)
Baldintzapeko jauziak dira; hots, jauzia egiten da baldintza bat betetzen bada
(ingelesez, branch, adarkatu). Konparazio sinple bat da baldintza: aginduan
adierazten den erregistroaren edukia 0 konstantearekin konparatzen da. Sei
konparazio erabil daitezke: eq (berdina, equal), ne (desberdina, not-equal), ls
(txikiagoa, less than), le (txikiago edo berdina, less or equal), gt
(handiagoa, greater than), eta ge (handiago edo berdina, greater or equal).
Helburuak adierazteko etiketak erabiltzen badira ere, jauzi-helbidea jauzi-
aginduaren helbidearekiko erlatiboa da; hots, jauzi-aginduaren helbideari
desplazamendu bat gehitzen zaio helburu-helbidea lortzeko.


Honako bost adibide hauetan, jauzi-aginduen erabilera batzuk lantzen dira. Goi-
mailako algoritmoak Cz ematen dira.


2.2.1 Adibidea
Bektore baten osagaien batura kalkulatzen duen programa bat idatzi behar da.
Bektorearen hasiera-balioak hauek dira: 5,7,7,100 eta -20. Emaitza BATURA
aldagaian utzi behar da.


Eragiketa betetzeko,goi-mailako hizkuntzetakoforegitura programatu behar da.
Egitura hori begizta honetan ageri da:






                            (C)


                            BATURA = 0;
                            for (i=0; i<5; i++)
                            BATURA=BATURA+BEKT[i];


Hainbat soluzio eman daitezke. Esaterako, hona hemen aukera bat, TXORI
mihiztadura-hizkuntza erabiliz:


.title BATU2

BEKT: .value 5, 7(2), 100, -20;
BATURA: .word 1;

.proc main

addi r10, r0, #0 {hasieratur10,tartekobaturakgordekodituenerregistroa}
movi r1, #0 {begiztarenbukaerakontrolatzeko:
indizeaezdainoiz5izango,0tik4rabitarteanegongodelako}

for: sub r11, r1, #5 {egiaztatubegizta-iterazioguztiakegindiren}
beq r11, buk{indizea
5bada,hots,kenketarenemaitza0bada,orduanbektore-osagaiguztiakprozesatudira:
bukatu}
ldx r3, BEKT[r1] {irakurribektore-osagaibat}
add r10, r10, r3 {gehitutartekobaturari}

addi r1, r1, #1 {eguneratuindizea,hurrengoosagaiairakurtzeko}
jmp for {atzeraegin,begiztarenexekuzioabukatudenegiaztatzeko}
buk: st r10, BATURA {azkenik,batuketaguztienemaitzaBATURAaldagaianidaztenda}
retm

.endp main
.end

Batu behar den osagai kopurua programaren agindu kopuruaren independentea da.
Gainera, edozein bektore-luzera prozesatu ahal izateko, nahikoa da aurreko
programakomovir1,#5aginduamovir1,#osag_kopaginduarekin ordezkatzea,
nonosag_kopbektorearen osagai kopurua den.
3.2.2 irudian ageri da nola exekutatzen den 3.3.1 adibideko programa, aginduz
agindu, BIRD konputagailuan (simuladorean). Ikus daitekeenez, aginduak
sekuentzialki exekutatzen direnean, binaka handitzen da PCaren balioa; aldiz,
jauzi bat exekutatzen denean, aurrera zein atzera, agindu-sekuentzia hautsi
egiten da (esaterako, 16400 → 16390). Jakina, begizta osatzen duten aginduak
errepikatzen direnean, PC erregistroaren balioak ere (agindu horien helbideak)
errepikatzen dira.
Agindua Ri1 Ri2 RhMemoria@
Edukia

PC=16384 addi_r10,r0,#0 R10 [000000]
PC=16386 movi_r1,#0 R01 [000000]
PC=16388for: subi_r11,r1,#5 R01 [000005] R11 [-00005]
PC=16390 beq_r11,buk R11 [-00005]
PC=16392 ldx_r3,BEKT[r1] R01 [000000] R03 [000005] @ 0 5
PC=16394 add_r10,r10,r3 R10 [000000] R03 [000005] R10 [000005]
PC=16396 addi_r1,r1,#1 R01 [000000] R01 [000001]
PC=16398 jmp_for
PC=16400 for: subi_r11,r1,#5 R01 [000001] R11 [-00004]
PC=16390 beq_r11,buk R11 [-00004]
PC=16392 ldx_r3,BEKT[r1] R01 [000001] R03 [000007] @ 1 7
PC=16394 add_r10,r10,r3 R10 [000005] R03 [000007] R10 [000012]
PC=16396 addi_r1,r1,#1 R01 [000001] R01[000002]
PC=16398 jmp_for
PC=16400for: subi_r11,r1,#5 R01[000002] R11 [-00003]
PC=16390 beq_r11,buk R11 [-00003]
PC=16392 ldx_r3,BEKT[r1] R01 [000002] R03 [000007] @ 2 7
PC=16394 add_r10,r10,r3 R10 [000012] R03 [000007] R10 [000019]
PC=16396 addi_r1,r1,#1 R01 [000002] R01 [000003]
PC=16398 jmp_for
PC=16400 for: subi_r11,r1,#5 R01 [000003] R11 [-00002]
PC=16390 beq_r11,buk R11 [-00002]
PC=16392 ldx_r3,BEKT[r1] R01[000003] R03 [000100] @ 3 100
PC=16394 add_r10,r10,r3 R10 [000019] R03 [000100] R10 [000119]
PC=16396 addi_r1,r1,#1 R01 [000003] R01 [000004]
PC=16398 jmp_for
PC=16400 for: subi_r11,r1,#5 R01 [000004] R11 [-00001]
PC=16390 beq_r11,buk R11 [-00001]
PC=16392 ldx_r3,BEKT[r1] R01 [000004] R03 [-00020] @ 4 -20
PC=16394 add_r10,r10,r3 R10 [000119] R03 [-00020] R10 [000099]
PC=16396 addi_r1,r1,#1 R01 [000004] R01 [000005]
PC=16398 jmp_for
PC=16400 for: subi_r11,r1,#5 R01 [000005] R11 [000000]
PC=16390 beq_r11,buk R11 [000000]
PC=16392 buk: st_r10,BATURA R10 [000099] @ 5 99
PC=16402 retm_

****** 3.2.2 irudia.3.2 adibideko programaren exekuzioaren aztarna. ******






Ohikoa da bektore baten osagaiak pantailan ikusi nahi izatea; programaren
funtzionamendu egokia egiaztatzeko, esaterako. Horretarako, outm#kop,aldag
agindua erabil daiteke. Agindu horrek bi argumentu behar ditu. Lehenengoa, kop,
bistaratu nahi den osagai kopurua da, zenbaki positibo bat 0 eta 511 artean (10
bit, 2rako osagarrian); bigarrenak, aldag, memoria-helbide bat da, eta
adierazten du zein helbidetatik aurrera dauden osagai horiek memorian. Helbide
hori adierazteko, bi aukera daude: (a) helbide absolutu bat ('@' ikurra eta
zenbaki arrunt bat); edo (b) programan erazagututako aldagai baten izena
(gogora ezazu aldagai baten izenak bere memoriako helbidea adierazten duela).
Agindu horren erabileraren adibide bat 3.2.2 adibidean ageri da.


2.2.2 Adibidea
Idatz ezazu programa bat,V1etaV2bektoreak batu eta emaitzaBATURAbektorean uzten
duena. Honako hauek diraV1etaV2bektoreak:
V1= (5, 7, 7, 100, –20, 5, 5, 5, 5, 5)
V2= (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)


Eragiketa hori betetzeko, algoritmo hau erabil daiteke:




                            (C)


                            for (i=0; i<10; i++)
                            BATURA[i]=V1[i]+V2[i];


Honela idatz daiteke algoritmo hori TXORI hizkuntzaz:



.title BEKBATU

V1: .value 5, 7(2), 100, -20, 5(5);
V2: .value 1(10);
BATURA: .word 10; {BATURA,hasieratugabeko10osagaikobektorea}

.proc main

mov r1, r0 {hasieratur1erregistroa,indizegisaerabiltzeko}
movi r2, #10 {10ekobatkargatu,iteraziokopuruakontrolatzeko}

for: sub r3, r2, r1
beq r3, buk {egiaztatuforbegiztarenbukaera}

ldx r4, V1[r1]
ldx r5, V2[r1]
add r6, r4, r5
stx r6, BATURA[r1] {BATURA[i]=V1[i]+V2[i]}

addi r1, r1, #1 {eguneratuindizea,hurrengoosagaiakprozesatzeko}
jmp for {atzerajoan,forbegiztarenbukaeraegiaztatzeko}

buk: retm

.endp main
.end



Aldaketatxo bat egin daiteke programan,BATURAbektorearen osagaiak pantailan
ikustarazteko,outmagindua erabiliz:


...
buk: outm #10, BATURA
{edooutm#10,@20,BATURAaldagaiarenhasierakohelbidea20baldinbada,datu-
bloketikabiatuta}
retm
...







Goi-mailako hizkuntzetan, ohikoak dira egitura batzuk aginduen fluxu
sekuentziala hausteko —if ... then ... else ...— eta begiztak antolatzeko, hau
da, kode zati bat n aldiz errepikatzeko —for,while, do, ...—. Aurreko
adibideetan erabili dugu for egitura, eta, hurrengo hiru adibideetan, gainerako
egiturak nola itzultzen diren mihiztadura-hizkuntzara azalduko dugu.


2.2.3 Adibidea
If...then...else... egitura erabiltzeko, honako algoritmo hau programatuko
dugu:




                          (ADA)          (C)


                          if X >= Y then if (X >= Y)
                          HANDIENA       HANDIENA=X;
                          :=X;           else
                          else           HANDIENA=Y;
                          HANDIENA:=Y;
                          end if;



non bi zenbaki,XetaY, konparatzen baitira, eta handienaHANDIENAaldagaian uzten
baita.


Honela itzul daiteke algoritmo hori TXORI mihiztadura-hizkuntzara:




.title IF

X: .value 15;
Y: .value 16;
HANDIENA:.word 1;

.proc main

ld r1, X
ld r2, Y
sub r3, r1, r2 {konparatuXetaY,kenketabateginez}
bls r3, else {r3negatiboabada,orduanY>X}

mov r10, r1 {handiena,X,r10erregistroanuztenda}
jmp buk

else: mov r10, r2 {handiena,Y,r10erregistroanuztenda}
buk: st r10, HANDIENA {gordehandiena,r10,HANDIENAaldagaian}

retm

.endp main
.end







2.2.4 Adibidea
XetaYzenbakien zatitzaile komunetan handiena kalkulatzen duen programa idatz
behar da (X, Y > 0). Adibidea egokia dawhilekontrol-egitura aztertzeko.


Whileetaforkontrol-egiturak oso antzekoak dira. Biak begiztak dira, eta beraz,
hainbat aldiz errepikatzen dute kode zati bat. Oro har, iterazio kopurua
aurretik ezagutzen denean,foregitura erabiltzen da, eta, ezagutzen ez denean,
berriz,whileegitura.
Adibideari ekiteko, hau daXetaYzenbakien zatitzaile komunetan handiena
kalkulatzeko algoritmo bat:




                               (C)


                               while (X != Y)
                               {
                               if(X>Y)
                               X=X-Y;
                               else
                               Y=Y-X;
                               }
                               ZKH=X;/*ZKH=X=Y*/


Emaitza, zatitzaile komunetan handiena,ZKHaldagaian utziko da.



.title WHILE

X: .value 12;
Y: .value 18;
ZKH: .word 1;

.proc main

ld r1, X {r1-ekX-renpaperabetetzendu}
ld r2, Y {etar2-k,Y-rena}

while: sub r3, r1, r2 {begiztatikateratzekobaldintzaX-Y}
beq r3, buk {r3=0bada,X=Y,kalkuluabukatuda}

bls r3, txiki {r3negatiboada,berazX<Y}

sub r1, r1, r2 {thenadarra:X>Y;beraz,eguneratuX}
jmp while {jarraitubegiztarekin}

txiki: sub r2, r2, r1 {elseadarra:X<Y;beraz,eguneratuY}
jmp while {jarraitubegiztarekin}

buk: st r2, ZKH {bukatudakalkulua:idatziemaitzaZKHaldagaian}
retm
{nahiizanezgero,aurrekoalgoritmoarekinbatetortzeko,XetaYaldagaiakereeguneradaitezke}
.endp main
.end





2.2.5 Adibidea
Azken adibide honetan,do(edoloopedorepeat,hizkuntzaren arabera)izeneko kontrol-
egitura erabiliko da. Adibide gisa, ondo sartu arte, pasahitza eskatzen duen
programa idatziko da.


Dokontrol-egitura erewhileetaforegituren antzekoa da. Hau da desberdintasun
bakarra: iterazio kopurua kontrolatzen duen aldagaia begiztaren bukaeran
aztertzen da, ez hasieran. Ondorioz, gutxienez, behin exekutatzen da begiztaren
gorputza, lehenengo egiaztatzea egin baino lehen. Beraz, adi egon behar da:
doegitura etawhile/foregiturak ez dira beti baliokideak.
Honako hau dadobegiztaren egitura:




                              (C)


                              do
                              {
                              begiztarengorputza;
                              indizeakeguneratu;
                              }while(baldintza);


Dobegiztaren adibide praktiko bat ikustearren, honako eragiketa hau
programatuko dugu: ondo sartu arte pasahitza eskatu behar da.
Hau izan daiteke algoritmoa:




                       (C)


                       do {
                       printf(“Sartupasahitza:\n”);
                       scanf(“%d”,&n);
                       }while(n==clave);




Eta, mihiztadura-hizkuntzaz, honela idatz daiteke:



.title repeat

kodea: .value 12;

.proc main

ld r2, kodea {kargatu,r1erregistroan,kodea}
do: outm “Sartu pasahitza” {pantailaratupasahitzaeskatzenduenesaldia}
in {sartutakobalioajaso,r1erregistroanjasotzenda}

sub r3, r1, r2 {bibalioenartekokenketar3erregistroanjaso}

bne r3, do
{r3renbalioa0rendesberdinabada,zenbakiakezdiraberdinaketaberriroeskatubeharkodapasahitza.Horretarako,doetiketarajauzieginez}
retm {amaitu}

.endp main
.end



Adi:dobegiztanaldiz errepikatzen denean,naldiz egiaztatzen da irteera-
baldintza; ordea,foretawhilebegizten kasuan,n+1 aldiz egiaztatu behar da
baldintza hori. Halaber,dobegiztetan ohikoa da agindu gutxiago erabili behar
izatea,foretawhilebegiztekin alderatuta, lan bera egiteko. Hori guztia kontuan
hartuta, azkarragoa ohi dadoegitura.




