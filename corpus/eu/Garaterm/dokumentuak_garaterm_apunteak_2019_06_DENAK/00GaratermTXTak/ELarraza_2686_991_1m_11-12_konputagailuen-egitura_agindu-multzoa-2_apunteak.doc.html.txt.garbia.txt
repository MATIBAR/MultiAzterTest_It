                                   2.2_BEKTOREAKETAJAUZIAK Lehenengo kapituluan esan den bezala, beraren makina-hizkuntza da konputagailu batek interpreta dezakeen hizkuntza bakarra. Makina-hizkuntzako aginduak konputagailuaren arkitektura-ezaugarrien mende daude, eta zerokoen eta batekoen segiden bidez adierazten dira (kodeketa bitarra). Lehenengo konputagailuetarako idatzi ziren programak, makina-hizkuntzaz idatzi ziren. Hala ere, oso astuna da zerokoen eta batekoen segiden bidez programak idaztea; akats asko egiten dira, eta oso zaila da programa zuzenak sortzea. Arazo horiek gainditzeko asmoz, ahalmen semantiko handiagoko hizkuntza sinbolikoak sortu ziren. Hizkuntza horien artean, mihiztadura-hizkuntza da makina-hizkuntzatik hurbilen dagoena; edukiera semantiko gutxienekoa, alegia. Beste muturrean, goi- mailako hizkuntzak ditugu. Hizkuntza sinbolikoak erabiliz, programak errazago idazten dira, baina erabiltzen diren aginduak ezin dira zuzenean konputagailuan exekutatu. Izan ere, programa horiek itzuli egin behar dira konputagailuak ulertzen duen hizkuntza bakarrera, eta, itzulpen horretarako, programa bereziak erabili behar dira: mihiztatzaileak (mihiztadura-hizkuntzetarako) eta konpiladoreak (goi-mailako hizkuntzetarako). Goi-mailako hizkuntzak dira programatzaileek gehien erabiltzen dituztenak (ADA, Cobol, Fortran, C, Lisp, Java, ...). Hizkuntza horietan programatzeko ez da konputagailuaren arkitektura ezagutu behar, hizkuntzen sintaxia makinaren baliabideen guztiz independentea baita. Aipatu dugun moduan, goi-mailako hizkuntzen aginduen edukiera semantikoa makina-hizkuntzako aginduena baino askoz altuagoa da. Hori dela eta, agindu bakar batekin, makina-hizkuntzako n agindu ordezkatzen dira (1:n korrespondentzia dago). Beraz, makina-hizkuntzako aginduekin erkatuta, goi-mailako aginduek lan gehiago egiten dute (eta, ondorioz, haien exekuzio-denbora altuagoa da). Lehen aipatu bezala, mihiztadura-hizkuntza da makina-hizkuntzatik hurbilen dagoen hizkuntza sinbolikoa. Aginduak mnemoteknikoen bidez idazten dira; izan ere, mihiztadura-hizkuntzaz idatzi dira aurreko kapituluetako programak. Mihiztadura-hizkuntzako agindu batek makina-hizkuntzako agindu bat ordezkatzen du, hau da, erlazioa 1:1 da. Horregatik, mihiztadura-hizkuntza zuzenki erlazionatuta dago konputagailuaren ezaugarriekin. Mihiztadura-hizkuntzako aginduek konputagailuaren baliabideak —erregistroak, memoria, edo sarrera/ irteerako gailuak— erabiltzen dituzte zuzenean. Beraz, prozesadore bakoitzak mihiztadura-hizkuntza desberdina, berea, erabiltzen du. Kapitulu honetan, TXORI mihiztadura-hizkuntza nola erabili behar den azalduko da, batik bat datu-egiturak (bektoreak eta matrizeak) maneiatzeko eta agindu- fluxuaren kontrol-egiturak gauzatzeko; hori guztia hainbat adibideren bidez egingo da. 2.2.1 NOLA ERABILI BEKTOREAK TXORI HIZKUNTZAN Bektoreak nola erabiltzen diren ikusteko, zenbaki osozko bektoreekin hasiko gara. Gogoratu: bektore bat datu-zerrenda bat besterik ez da, ondoz ondoko memoria-posizioetan gordeta. Bi gai landu beharko ditugu. Batetik, bektoreak nola erazagutu sasiaginduen bidez. Eta, bestetik, bektoreen osagaiak nola atzitu modu egokienean. 2.2.1.1 Bektoreak erazagutzea Bi sasiagindu erabili ditugu jadanik aldagaiak erazagutzeko: .word eta .value. Lehenengoak, tokia erreserbatzen du memorian aldagai baterako. Bigarrenak, tokia erreserbatzeaz gain, hasiera-balio jakin bat esleitzen dio aldagaiari. Izan ere, bi sasiagindu horiek erabili behar dira bektoreak ere erazagutzeko. Bektore-osagaiak ez badira hasieratu behar, nahikoa da .wordsasi-agindua erabiltzea. Argumentu bakarra onartzen du: memorian erreserbatu behar den posizio kopurua (balio positiboa, noski). 3.1 irudian, honako adibide hau ageri da: C: .word4; C bektorerako, memoriako ondoz ondoko lau posizio erreserbatzen dira, besterik gabe. Bektore-osagaiei hasierako balioak emateko, aldiz, .value sasiagindua erabili behar da. Hasiera-balioak komen bidez bereizi behar dira; lehenengo balioa lehenengo osagaiari dagokio, bigarrena bigarrenari, eta abar. 3.1 irudian, honako adibide hau ageri da: A: .value6,7,–5,3; A bektorerako, ondoz ondoko lau posizio erreserbatzen dira, eta 6, 7, –5 eta 3 balioekin hasieratzen dira, hurrenez hurren. Askotan, hasiera-balio bera esleitu behar zaio ondoz ondoko hainbat osagairi. Balio horiek guztiak errepikatu beharrean, balio bakar bat eta, parentesien artean, errepikapen kopurua adieraz daitezke. 3.1 irudian, honako beste adibide hau ageri da: B: .value1(4); B aldagairako, ondoz ondoko lau memoria-posizio erreserbatzen dira, eta hasiera-balio bera hartzen dute guztiek, 1ekoa. 2.2.1.2 Bektore baten osagaiak atzitzea: helbideratze absolutua eta indexatua Bektore baten osagaiak homogeneoak direnez, hots, denak luzera eta oinarrizko mota berekoak, osagaiaren memoria-helbidea, hi,kalkulatzeko, beharrezkoa dugu jakitea bektorearen hasierako helbidea, h0,eta osagaiaren posizioa bektorean, i. Informazio hori erabiliz, i osagaiaren helbidea hau izango da: hi=h0+ixlnon l balioak osagai bakoitzaren luzera adierazten duen, hots zenbat memoria- posizio okupatzen dituen. Helbide hori erabiliz, ld edo st aginduak erabil daitezke osagaia hori atzitzeko (helbideratze-modu absolutua). Hala ere, atzipen mota hori ez da erosoa, programatzaileak berak kalkulatu behar baitu osagai bakoitzaren helbidea. Egokia litzateke, beraz, helbideratze-modu eraginkorragoak izatea bektoreen osagaiak atzitu ahal izateko. Goi-mailako hizkuntzetan, bektore baten osagai bat adierazteko, bektorearen izena eta, ondoren, osagaiaren indizea edo posizioa adierazi ohi da. Adibidez, ADA hizkuntzaz, B bektorearen i osagaia atzitzeko, B(i)idatzi behar da (C hizkuntzaz, B }  addi r1, r1, #1 {eguneratuindizea,hurrengoosagaiakprozesatzeko} jmp for {atzerajoan,forbegiztarenbukaeraegiaztatzeko}  buk: retm  .endp main .end    Aldaketatxo bat egin daiteke programan,BATURAbektorearen osagaiak pantailan ikustarazteko,outmagindua erabiliz:   ... buk: outm #10, BATURA {edooutm#10,@20,BATURAaldagaiarenhasierakohelbidea20baldinbada,datu- bloketikabiatuta} retm ...        Goi-mailako hizkuntzetan, ohikoak dira egitura batzuk aginduen fluxu sekuentziala hausteko —if ... then ... else ...— eta begiztak antolatzeko, hau da, kode zati bat n aldiz errepikatzeko —for,while, do, ...—. Aurreko adibideetan erabili dugu for egitura, eta, hurrengo hiru adibideetan, gainerako egiturak nola itzultzen diren mihiztadura-hizkuntzara azalduko dugu.   2.2.3 Adibidea If...then...else... egitura erabiltzeko, honako algoritmo hau programatuko dugu:                               (ADA)          (C)                             if X >= Y then if (X >= Y)                           HANDIENA       HANDIENA=X;                           :=X;           else                           else           HANDIENA=Y;                           HANDIENA:=Y;                           end if;    non bi zenbaki,XetaY, konparatzen baitira, eta handienaHANDIENAaldagaian uzten baita.   Honela itzul daiteke algoritmo hori TXORI mihiztadura-hizkuntzara:     .title IF  X: .value 15; Y: .value 16; HANDIENA:.word 1;  .proc main  ld r1, X ld r2, Y sub r3, r1, r2 {konparatuXetaY,kenketabateginez} bls r3, else {r3negatiboabada,orduanY>X}  mov r10, r1 {handiena,X,r10erregistroanuztenda} jmp buk  else: mov r10, r2 {handiena,Y,r10erregistroanuztenda} buk: st r10, HANDIENA {gordehandiena,r10,HANDIENAaldagaian}  retm  .endp main .end        2.2.4 Adibidea XetaYzenbakien zatitzaile komunetan handiena kalkulatzen duen programa idatz behar da (X, Y > 0). Adibidea egokia dawhilekontrol-egitura aztertzeko.   Whileetaforkontrol-egiturak oso antzekoak dira. Biak begiztak dira, eta beraz, hainbat aldiz errepikatzen dute kode zati bat. Oro har, iterazio kopurua aurretik ezagutzen denean,foregitura erabiltzen da, eta, ezagutzen ez denean, berriz,whileegitura. Adibideari ekiteko, hau daXetaYzenbakien zatitzaile komunetan handiena kalkulatzeko algoritmo bat:                                    (C)                                  while (X != Y)                                {                                if(X>Y)                                X=X-Y;                                else                                Y=Y-X;                                }                                ZKH=X;/*ZKH=X=Y*/   Emaitza, zatitzaile komunetan handiena,ZKHaldagaian utziko da.    .title WHILE  X: .value 12; Y: .value 18; ZKH: .word 1;  .proc main  ld r1, X {r1-ekX-renpaperabetetzendu} ld r2, Y {etar2-k,Y-rena}  while: sub r3, r1, r2 {begiztatikateratzekobaldintzaX-Y} beq r3, buk {r3=0bada,X=Y,kalkuluabukatuda}  bls r3, txiki {r3negatiboada,berazX<Y}  sub r1, r1, r2 {thenadarra:X>Y;beraz,eguneratuX} jmp while {jarraitubegiztarekin}  txiki: sub r2, r2, r1 {elseadarra:X<Y;beraz,eguneratuY} jmp while {jarraitubegiztarekin}  buk: st r2, ZKH {bukatudakalkulua:idatziemaitzaZKHaldagaian} retm {nahiizanezgero,aurrekoalgoritmoarekinbatetortzeko,XetaYaldagaiakereeguneradaitezke} .endp main .end      2.2.5 Adibidea Azken adibide honetan,do(edoloopedorepeat,hizkuntzaren arabera)izeneko kontrol- egitura erabiliko da. Adibide gisa, ondo sartu arte, pasahitza eskatzen duen programa idatziko da.   Dokontrol-egitura erewhileetaforegituren antzekoa da. Hau da desberdintasun bakarra: iterazio kopurua kontrolatzen duen aldagaia begiztaren bukaeran aztertzen da, ez hasieran. Ondorioz, gutxienez, behin exekutatzen da begiztaren gorputza, lehenengo egiaztatzea egin baino lehen. Beraz, adi egon behar da: doegitura etawhile/foregiturak ez dira beti baliokideak. Honako hau dadobegiztaren egitura:                                   (C)                                 do                               {                               begiztarengorputza;                               indizeakeguneratu;                               }while(baldintza);   Dobegiztaren adibide praktiko bat ikustearren, honako eragiketa hau programatuko dugu: ondo sartu arte pasahitza eskatu behar da. Hau izan daiteke algoritmoa:                            (C)                          do {                        printf(“Sartupasahitza:\n”);                        scanf(“%d”,&n);                        }while(n==clave);     Eta, mihiztadura-hizkuntzaz, honela idatz daiteke:    .title repeat  kodea: .value 12;  .proc main  ld r2, kodea {kargatu,r1erregistroan,kodea} do: outm “Sartu pasahitza” {pantailaratupasahitzaeskatzenduenesaldia} in {sartutakobalioajaso,r1erregistroanjasotzenda}  sub r3, r1, r2 {bibalioenartekokenketar3erregistroanjaso}  bne r3, do {r3renbalioa0rendesberdinabada,zenbakiakezdiraberdinaketaberriroeskatubeharkodapasahitza.Horretarako,doetiketarajauzieginez} retm {amaitu}  .endp main .end    Adi:dobegiztanaldiz errepikatzen denean,naldiz egiaztatzen da irteera- baldintza; ordea,foretawhilebegizten kasuan,n+1 aldiz egiaztatu behar da baldintza hori. Halaber,dobegiztetan ohikoa da agindu gutxiago erabili behar izatea,foretawhilebegiztekin alderatuta, lan bera egiteko. Hori guztia kontuan hartuta, azkarragoa ohi dadoegitura.    
