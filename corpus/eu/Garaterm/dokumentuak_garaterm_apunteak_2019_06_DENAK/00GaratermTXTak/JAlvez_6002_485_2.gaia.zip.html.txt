




Kapitulua 2
****** Programen espezifikazioa ******
***** 2.1 Espezifikazioaren kontzeptua *****
Hiztegiek diotenez, espezifikazioa egin beharreko lanaren deskribapen zehatza
da.
Definizio horren haritik, programen espezifikazioa diogunean, programen
egitekoaren deskribapen zehatzaz ari gara.
Bi osagai izan ohi ditu programen espezifikazioak: batetik, datuek bete behar
dituzten propietateak adierazten dira; bestetik, emaitzaren ezaugarriak
deskribatzen dira. Bi parte horiek elkarren osagarri dira, eta bien
konposaketak osotasuna ematen dio deskribapenari.
Datuen eta emaitzaren arteko erlazio hori funtzio baten gisara uler daiteke:
datuak lirateke funtzioaren sarrera, eta emaitza, berriz, funtzioaren irteera.
Espezifikazioa funtzioaren deskribapen zehatza da, horretara. Programa, ordea,
funtzioaren inplementazioa da, hau da, datuetatik abiatuta emaitzak lortzeko
modu jakin bat. Eta, noski, espezifikazio bat emanda, programa bat baino
gehiago inplementa daitezke espezifikazio hori betetzen dutenak.
*** Helburuak ***
Espezifikazioa programagintzako hainbat alorretan erabiltzen da.
Programen diseinuan berebiziko garrantzia du. Izan ere, edozein programaren
diseinurako premiazkoa da ebatzi beharreko problemaren ezagutza zehatza
(anbiguetaterik gabea). Ezagutza hori diseinuari ekin aurretik eduki behar da,
diseinatu ahala problemaren deskribapenaz jabetzea akats-iturri larria delako.
Problema espezifikatzeak ideiak egituratzera behartzen gaitu eta aspektu
nabariak agerian uztera, bidenabar. Aspektu hauek, espezifikazioan ez bada,
diseinuan agertzen dira edo, are okerrago, ez dira agertzen, eta orduan
programa desegokia izango da, ez baitu nahi dugun problema ebatziko.
Programak eta aplikazio informatikoak talde-lanean egin ohi dira. Hori horrela,
espezifikazioa komunikaziorako bitarteko ezinbestekoa da. Modulutako banaketa
sistemaren eginbeharrak zehatz-mehatz ezagutuz egin behar da, eta modulu
bakoitzeko diseinatzaileak, inolako anbiguetaterik gabe ezagutu behar ditu
problema orokorra eta beste moduluekiko elkarrekintzak.
Programen testak diseinatzeko ere ezinbestekoak dira espezifikazioak: ezin dira
testeatu programak beren eginkizuna zehaztasunez ezagutzen ez bada.
Bestalde, ez dugu ahantzi behar programak behin egin eta askotan irakurtzen
direla. Programa bat mantentzeko beharrezkoa da dokumentazio aproposa
erabiltzea, edonork programa horrek zer egiten duen zehazki uler dezan aparteko
ahaleginik gabe. Gerora ere, aldaketaren bat burutu beharko denean,
ezinbestekoa izango da dokumentazioa. Kontuan hartu behar da, gainera,
aldaketak egiten dituena eta hasierako diseinua egin zuena ez direla pertsona
bera izaten normalean.
Programen egiaztapenerako ere espezifikazioak dira abiapuntua, azken batean
programak egiaztatzea espezifikazioak betetzen dituztela formalki frogatzea
baita, hau da, diseinatu zeneko eginbeharrak betetzen dituela frogatzea. Beraz,
egiaztapenean oinarritzen diren diseinu-metodologien oinarria ere badira
espezifikazioak.
Programen eratorpena eta sintesi automatikoa egiten duten aplikazioek ere
espezifikazioetan dute oinarria. Arlo honetan, espezifikazio-lengoaia
exekutagarriak ere badira, hau da, programazio-lengoaia bilakatu diren
espezifikazio-lengoaiak, nolabait problemaren deskribapena egikaritzen dutenak.
Hala bada, besteak beste, diseinuan, talde-lanean, probetan, mantentze-lanetan,
egiaztapenean, eratorpenean eta sintesian baliagarriak dira guztiz
espezifikazioak.
*** Ezaugarriak ***
Esana dugu espezifikazioei zehatz eta argi izatea eskatzen zaiela, jatorrizko
problemaren ezagutza anbiguetaterik gabea ekarri behar dutelako. Oro har,
espezifikazio egokiek propietate hauek izan beharko lituzkete:
•argitasuna (ulerterraza)
•laburtasuna (erredundantziarik gabea)
•doitasuna (anbiguotasunik ez)
•murriztasunaren eta orokortasunaren arteko oreka
Ezaugarri horiek betetzen dituzten deskribapenak espezifikazio egokitzat jotzen
dira. Ez dago molde bakarra espezifikazioak idazteko. Formatu eta lengoaia
desberdinak balia daitezke espezifikatzean.
Bi sailetan banatu ohi dira espezifikazio-lengoaiak: formalak eta informalak.
Lengoaia bat formaltzat hartuko dugu baldin eta bere sintaxia eta semantika
formalki definituta badaude (zehaztasun matematikoz). Espezifikazio ez-
formalerako teknikek, aldiz, edozein abstrakzio funtzionalen aspektu nabariak
klausulen bidez adierazteko formatua finkatzen dute. Moldea bai, baina
klausulak adierazteko lengoaia formalik ez dute ezartzen. Espezifikatzen
duenaren esku geratzen da, hortaz, notazio matematiko eta/edo teknikoaren
hautaketa, lengoaia naturalaren laguntzaz deskribapen argiak, laburrak eta
zehatzak idatzi ahal izateko.
Helburuak baldintzatuko du lengoaiaren formaltasun-maila: taldeen arteko
komunikaziorako, test-diseinurako edo dokumentaziorako lengoaia ez oso formala
nahikoa izan daiteke; baina programen egiaztapenerako, eratorpenerako,
sintesirako edo espezifikazioen exekuziorako ezinbestekoa da lengoaia formala
izatea, espezifikazioak matematikoki eta/edo automatikoki tratatzen baitira.
***** 2.2 Asertzioak: egoera-multzoak adierazteko formulak *****
Aurreko atalean esan dugunez, espezifikazioak datu-sarreren eta emaitzen arteko
erlazioa adierazteko balio du: azken batean, zer egiten duen programa batek.
Baina espezifikazioak ez du adierazten zer egin behar den erlazio hori
lortzeko; hau da, nola kalkulatzen diren emaitzak datu-sarreretatik abiatuz.
Kontuan hartuta, gainera, espezifikazio bat era desberdinetan inplementa
daitekeela, espezifikazioak ez du deskribatzen programa edo ebazpen jakin baten
barruko antolamendua.
Programa bat aginduen segidatzat har daiteke. Agindu bakoitzak programaren
aldagai baten edo batzuen balioak aldatzen ditu. Aldagaien hasierako balioak
ezagutzen baditugu, orduan ezagut daiteke zein den agindu baten exekuzioaren
emaitza. Horrela, datu-sarreratik emaitzetara gertatzen den transformazio-
prozesua esplizituki errepresenta daiteke.
Programaren egoera deituko diogu programaren aldagaiek une jakin batean
dituzten balioen multzoari. Beraz, agindu bakoitzak egiten duena programaren
egoera aldatzea da.
Horrela bada, exekuzioaren une jakin bateko konputazio-egoerak (edo egoerak)
programa bateko aldagai guztien balioen deskribapena dira:
{aldagaiak}↦{balioak}
Konputazio-egoeraren kontzeptua hurrengo adibidearekin deskribatuko dugu.
Demagun x=31, y=7 eta hurrengo P programa ditugula:
     - - Datu-sarrerak: x, y zenbaki osokoak
     - - Emaitzak: z, h zenbaki osokoak
     begin
     (1)
      z := 0;
 (2)
      h := x;
 (3)
      whileh >= yloop
       z := z+1;
    (4)
       h := h-y;
    (5)
    end_loop;
 (6)
 end;
non x eta y-ren zatidura (z) eta hondar (h) osoa kalkulatzen den. Programa
honen hasierako konputazio-egoera honako hau da:
(1) {x=31∧y=7}
Programan agertzen diren beste aldagaiei (hau da, z eta h) oraindik ez diegu
baliorik eman, eta horregatik hasierako konputazio-egoeran ez dira agertzen:
edozein balio izan dezakete. Lehenengo agindua exekutatu ondoren (z := 0;), z
aldagaiak 0 balioa hartzen du. Beraz, bigarren konputazio-egoera
(2) {x=31∧y=7∧z=0}
da. Era berean, bigarren agindua (h := x;) exekutatutakoan gelditzen den
programaren konputazio-egoera
(3) {x=31∧y=7∧z=0∧h=31}
da. Ondoren, while aginduaren exekuzioa hasten da. Iterazioak aurrera egin
ahala, aldagaiek honako taula honetan adierazitako balioak hartzen dituzte:


   Iterazioa       Egoera         x          y         z         h
      2*1            (4)          31         7         1         31
      2-6            (5)          31         7         1         24
      2*2            (4)          31         7         2         24
      2-6            (5)          31         7         2         17
      2*3            (4)          31         7         3         17
      2-6            (5)          31         7         3         10
      2*4            (4)          31         7         4         10
      2-6            (5)          31         7         4         3
Azkenik, while aginduaren exekuzioa bukatu ondoren, programaren konputazio-
egoera
(6) {x=31∧y=7∧z=4∧h=3}
da. Horrenbestez, programak honako funtzio hau inplementatzen du
                       {x=31∧y=7} ↦ {x=31∧y=7∧z=4∧h=3}
non {x=31∧y=7} hasierako egoera den eta {x=31∧y=7∧z=4∧h=3} bukaerako egoera
den.
Jakina, aipatutako funtzioa ez da orokorra, datu-sarrera jakin bat baino
kontuan hartzen ez duelako. Hau da, x aldagaiak 31 balioa hartzen ez badu (edo
y aldagaiak 7), aurreko funtzioak ez du bukaerako balio egokia adieraziko.
Gainera, kontuan izan behar da programa batek datu-sarreren kopuru infinitua
har dezakeela. Horregatik, konputazio-egoerak erabiltzea ez da nahikoa programa
baten espezifikazio orokorra adierazteko.
Gabezia horri aurre egin eta adierazpide orokorrago baten bila, asertzioak
erabiltzen dira. Azken batean, asertzioak espresio logikoak dira, programetan
iruzkinen modura txertatzen direnak eta programako aldagaiek puntu jakin batean
betetzen dituzten propietateak adierazten dituztenak. Hortaz, asertzio
bakoitzak programaren puntu batean gerta daitezkeen egoeren multzoa (infinitua
izan daitekeena) errepresentatzen du. Asertzioa egiazko egiten duten egoerak
dira puntu horretan errepresentatzen direnak. Egoera horiek asertzioa betetzen
dutela esango dugu. Adibidez,
                                φ ≡ {x=y×z+h}
asertzioa hartuz gero, asertzio hori:
•{x=31∧y=7∧z=4∧h=3} egoeran egiazkoa da (eta egoera horrek asertzio hori
betetzen du).
•{x=31∧y=7∧z=4∧h=0} egoeran faltsua da.
•{x=31∧y=7} egoeran zehaztugabea da.
Asertzioen bidez, programa baten espezifikazioa adieraz daiteke. Adibidez,
bektore bateko elementuen batura kalkulatzen duen hurrengo programarekin egiten
den bezalaxe.
     begin {n≥1}
      i := 0;
      x := 0;
      whilei < nloop
       i := i+1;
       x := x+A(i);
    end_loop;
 end;

Asertzioak adierazteko, lengoaia formala erabiliko dugu, lehen mailako logika,
hain zuzen ere. Hau da, asertzio bakoitza lehen mailako logikako formula bat
izango da.
Lehen mailako logika (predikatu-logika eta predikatu-kalkulua izenak ere
hartzen ditu) lehen mailako lengoaien inferentzia aztertzeko sistema formal bat
da. Lehen mailako lengoaiak sinbolo (aldagai eta konstante) indibidualak
erabiltzen dituzten funtzioez eta predikatuez eta, aldi berean, aldagai
indibidualen kuantifikatzaileez osatutako lengoaia formalak dira. Oro har, guk
erabiliko ditugun indibiduoak zenbaki arruntak izango dira. Hau da, formulek
zenbaki arruntei buruzko propietateak edo erlazioak adieraziko dituzte, edo,
bestela esanda, gure domeinua N da. Salbuespen gisa, batzuetan karaktereak
(komatxo artean adierazitakoak) ere erabiliko ditugu, string-ekin lan egiteko.
**** 2.2.1 Asertzioak idazteko lehen mailako logikaren sintaxia ****
Lengoaia formal guztiek sintaxia eta semantika jakin bat dute. Asertzioen
idazkeran erabiliko dugun lengoaiaren sintaxiari dagokionean, formulak idazteko
alfabetoa ADA programazio-lengoaiari egokituko diogu eta, besteak beste, honako
sinbolo hauek erabiliko ditugu:
•Aldagai-sinboloak: x,y,z,…
•Konstante-sinboloak: 0,1,…,a,b,c,…
•Funtzio-sinboloak:
•Predikatu-sinboloak: <,=,>,…,bikoiti,bakoiti,…
Aldagai-, konstante- eta funtzio-sinboloak indibiduoak adierazteko erabiltzen
ditugu, terminoak osatuz. Predikatuak baliatzen dira formulak osatzeko
(konektatzaileekin eta kuantifikatzaileekin konbinatuz). Hau da, terminoek
indibiduoak adierazten dituzte, eta formulek indibiduoen arteko propietateak.
Terminoak errekurtsiboki defini daitezke:
•Termino sinpleak: aldagaiak eta konstanteak (funtzio 0-tarrak). Bektoreetako
elementu bakoitza ere termino sinple bat da.
•Termino konposatuak: funtzio n-tarrak n terminori aplikatuta (n>0).
Beste edozein adierazpen ez da terminoa izango. Adibidez,
x,0,1,a,true,false,A(i)
termino sinpleak dira, eta
termino konposatuak dira. Adibideetan ikus daitekeenez, bektoreko osagaiak ere
terminoak dira. Definizioak sinplifikatzeko, bektore bakoitza aldagai multzo
baten laburduratzat hartuko dugu eta, horregatik, bektore bateko osagai
bakoitza aldagai arrunt bezala erabil daiteke.
Era berean, formulak ere errekurtsiboki defini daitezke:
•Formula sinpleak edo atomoak: predikatu n-tarrak n terminori aplikatuta. true
eta false atomoak dira.
•Formula konposatuak: ≠ (negazioa, ukapena), ∧ (konjuntzioa, eta), ∨
(disjuntzioa, edo), → (inplikazioa, baldintza) eta (baliokidetza, baldintza
bikoitza) eragile logikoak, eta ∀ (unibertsala) eta ∃ (existentziala)
kuantifikatzaileak erabiltzen dira.
Ukapena konektatzaile bakuna da (formula bakar bati aplikatzen zaio), eta
konjuntzioa, disjuntzioa, baldintza eta baldintza bikoitza bitarrak (bi
formulari aplikatzen zaie) dira. Esate baterako, hurrengo espresioek
x<y,z=2,A(i)>A(j)+1,bakoiti(x),bikoiti(2)
atomoak adierazten dituzte, eta
formula konposatuak dira. Formula konposatuetan, aldagai bat atxikia da
kuantifikatzaile baten eraginpean badago. Atxikiak ez diren aldagaiak libreak
dira. Kontuan hartu true eta false konstanteak bai termino bai atomotzat
hartuko ditugula.
**** 2.2.2 Asertzioak idazteko lehen mailako logikaren semantika ****
Lehen mailako logikaren semantika estandarra erabiliko dugu N domeinuarekin.
Batetik, konektatzaileari buruz, ukapenaren interpretazioa ≠true≡false eta
≠false≡true da, eta konektatzaile bitarren egia-taula honako hau da:


     φ           ψ          φ∧ψ      φ∨ψ      φ→ψ
   false        false        false        false         true         true
   false         true        false         true         true        false
    true        false        false         true        false        false
    true         true         true         true        false        false
Bestetik, kuantifikatzaileei buruz, ∀xφ egiazkoa da φ betetzen bada edozein x∈N
baliotarako, eta ∃yψ egiazkoa da ψ betetzen bada y∈N balioren baterako.
Hala ere, askotan formula batek adierazi behar duen propietatea ez dute N
multzoko elementu guztiek betetzen, baizik eta N-ren azpi-multzo batek.
Horrelakoetan, aldagai atxikiei esleitu ahal zaizkien balioak murriztu egin
behar dira. Horretarako, patroi edo egitura ezagun bat erabiltzen dugu.
Lehenik, x aldagai atxikiak har ditzakeen balioak adierazten dira formula baten
bidez. Formula horrek domeinu izena hartzen du eta D(x) adierazpenarekin
errepresentatzen dugu. Normalean, formula hau sinplea da (atomo bat), baina
formula konposatuak ere erabil daitezke. Adibidez:
Bigarrenik, domeinuko elementuek bete behar duten propietatea adierazten da.
Erabiltzen den formulak propietate izena hartzen du eta P(x) adierazpenarekin
errepresentatzen dugu. Bi elementu hauekin osatzen den formulak honako egitura
hau du
D(x)⊗P(x)
non ⊗-k eragile logiko bat errepresentatzen duen kuantifikatzailearen arabera.
Kuantifikatzaile unibertsalarekin baldintza (→) erabiltzen da, eta
kuantifikatzaile existentzialarekin konjuntzioa (∧):
Edozein formuletan kuantifikatzaileren bat agertzen denean, aurreko patroiak
erabiltzea derrigorrezkoa da.
Kasu berezi gisa, aldagai atxikiak edozein N multzoko elementu har badezake
(domeinu unibertsala), orduan D(x)≡true da eta patroiak horrela sinplifika
daitezke: ∀xP(x) eta ∃xP(x).
Era berean, aldagai atxikiak baliorik hartu ezin badu (domeinu hutsa), orduan D
(x)≡false da eta formula osoa sinplifikatzen da:
Hau da, horrelakoetan, kuantifikatzaile unibertsala (∀) duen formula true
bihurtzen da (konjuntzioaren elementu neutroa), eta kuantifikatzaile
existentziala (∃) duen formula, false (disjuntzioaren elementu neutroa).
Izatez, kuantifikatzaileak laburduratzat har daitezke, errepikatzen diren
eragiketak orokortu eta biltzeko balio baitute. Horrela ikusita,
kuantifikatzaile unibertsalak konjuntzioa orokortzen du, eta kuantifikatzaile
existentzialak, disjuntzioa:


           Kuantifikatzailea                      Eragiketa orokortua
                   ∀                                     ∧
                   ∃                                     ∨
Adibidez:
∀x(1≤x<4→A(x)<8) ≡ A(1)<8∧A(2)<8∧A(3)<8
∃y(2<y≤5∧B(y)≥1) ≡ B(3)≥1∨B(4)≥1∨B(5)≥1
Horrela, kuantifikatzaileak erabiliz, propietate batzuk era labur batean
adieraz daitezke:
•“A(1..10) zenbaki osoko positiboen bektorea da”:
∀i(1≤i≤10→A(i)>0)
•“A(1..10)-k zehatz-mehatz zenbaki negatibo bat du”:
∃i(1≤i≤10∧A(i)<0∧∀j((1≤j≤10∧i≠j)→A(j)>0))
•“Badago zenbaki bat 5-en zatigarria dena”:
∃x(xmod5=0)(N domeinuarekin: D(x) ≡true  )
•“Edozein zenbaki bikoiti zenbaki ez-lehena da”:
∀x(xmod2=0→≠lehena(x))
non  lehena(x) ≡∀i  (  1 < i < x  → x  mod  i ≠0  )
Kuantifikatzailearen bidez formulak laburtzen diren antzera, terminoak ere
laburtu daitezke. Horretarako, funtzio-sinbolo hauek erabiltzen dira:
(batukaria), (biderkaria) eta N (kontakaria).
Batukarien eta biderkarien idazkera berdina da. Lehenik, aldagai atxikiaren
domeinua espezifikatzen da eta, bigarrenik, aldagai atxikia erabiltzen duen
termino bat adierazten da:
Honakoetan ere badira nabarmendu beharreko kasu partikularrak. Domeinua hutsa
denean, batukariak 0 balioa hartzen du (batuketaren elementu neutroa), eta
biderkariak, 1 (biderketaren elementu neutroa).
Hirugarrenak, kontakariak, adierazitako propietatea betetzen duten domeinuko
elementuen kopurua itzultzen du. Kasu honetan, kuantifikatzaile
existentzialarekin gertatzen den bezalaxe, D(x)∧P(x) patroia erabiltzen da,
baina zenbaki arrunt bat bueltatzen du. Adibidez:
Nx(1≤x≤7∧bikoiti(x))=3
Gainera, batukarian bezalaxe, domeinua hutsa denean, kontakariak 0 bueltatzen
du (batuketaren elementu neutroa).
Ondoren, batukaria, biderkaria eta kontakaria erabiliz adieraziko ditugu
propietate batzuk, adibide gisa:
•“A(1..10) bektoreko elementu guztien batura 50 baino handiago da”:
•“A(1..10) bektoreko k lehenengo elementuen biderkadura x da”:
•“3 elementua 5 aldiz agertzen da A(1..10) bektorean”:
Ni(1≤i≤10∧A(i)=3)=5
**** 2.2.3 Logikaren interpretazioa programen testuinguruan ****
Testuinguru honetan, konputazio-egoerek adieraziko dute formula bateko aldagai
libreen balioa. Horregatik, konputazio-egoera konkretu batean, formula batek
balioa (egiazkoa edo faltsua) duela esango dugu (edo definituta dagoela),
baldin eta soilik baldin bere aldagai libre guztiek balio bat badute egoera
horretan. Adibidez, konputazio-egoera {x=3∧y=4} bada:
•x≥y faltsua da.
•x+1=y∧y>2 egiazkoa da.
• faltsua da.
•∃z(z>0∧z+x=y) egiazkoa da.
•∀z(z>1→z+x>y) egiazkoa da.
Gainera, A=[2,5,3,6,1,8] bektorea dugularik:
•∃i(1≤i≤6∧(x=A(i)∨y=A(i))) egiazkoa da.
•∀i(1≤i≤6→A(i)≤x+y) faltsua da.
•∃i(1≤i≤6∧x=A(i))∧∃j(1≤j≤6∧y=A(j)) faltsua da.
•∃i(1≤i≤6∧∀j(i<j≤6→A(i)>A(j))) egiazkoa da.
Programa bateko asertzioak idazterakoan, badira kontuan hartu beharreko arau
eta murriztapen batzuk. Hona hemen murriztapen nagusiak:
•Programakoak diren aldagai libreen eta programakoak ez diren aldagai atxikien
(laguntzaileen) erabilera asertzioetan.
Asertzioetan aldagai libreak eta atxikiak ager daitezke, lehen ere esan
dugunez. Aldagai libre eta atxikien erabilera estuki lotuta dago programako
aldagaiekin, eta erabilera okerrak erabat aldaraz dezake formulen esanahia.
Kontuan hartu behar da, batetik, asertzio batek aldagai libreak baldin baditu
eta aldagai libre horiek ez badira programan agertzen, asertzio horrek ez duela
zentzurik izango: programaren konputazio-egoerarik ez du definitzen eta, beraz,
zehaztugabea da.
Bestetik, asertzio batek aldagai atxikiak baldin baditu eta aldagai atxiki
horiek programan agertzen badira, asertzio horrek ez du zentzurik izango.
Identifikadoreen talka saihestu egin behar da. Ez da erabili behar aldagai
atxiki batentzat programan agertzen den aldagai baten izena.
Arau garrantzitsua da honako hau: programan agertzen den edozein aldagaik
librea izan behar du asertzioetan. Eta, bestalde, ez dira inoiz nahastu behar
programako aldagaien eta aldagai atxikien identifikadoreak.
Adibidez, ekar dezagun hona bektore bateko elementuen batura kalkulatzen duen
programa:
     begin {n≥1}
      i := 0;
      x := 0;
      whilei < nloop
       i := i+1;
       x := x+A(i);
    end_loop;
 end;


Nabarmentzekoa da asertzioetan erabiltzen diren aldagai libre guztiak (A(1..n),
n, i, x) programan erabiltzen diren aldagaiak direla. Eta, bestetik, batukarian
erabiltzen den j aldagai atxikia ez da ageri programan. Zentzua galduko lukete
asertzioek batukariko aldagai atxiki moduan, adibidez, i edo x identifikadoreak
erabili izan balira.
•Formula bat ondo definituta dago konputazio-egoera batean baldin eta soilik
baldin:


•bere aldagai libre guztiek balio bat badute egoera horretan, eta


•formulako espresio guztien ebaluazioek balio definitua itzultzen badute egoera
horretan.
Aldagai libreek balioren bat hartu ondoren agertu behar dute asertzioetan.
Balio hori datu-sarreratik datorkiena izan daiteke, edo aldagaiak hasieratzetik
datorkiena.
Aurreko programara joz berriz, aldagai libre guztiek (A(1..n), n, i, x)
asertzioetan agertzen direnerako badute balioren bat. Ez luke zentzurik izango,
esate baterako, hasierako asertzioa {n≥1∧i=0∧x=0} izateak, artean i eta x
aldagaiak hasieratu gabe daude-eta.
*** def predikatua ***
Terminoak eta formulak ondo definituta egotea ezinbesteko baldintza da
programen konputazio-egoerari buruzko propietateak adierazi ahal izateko. Hori
dela eta, hemendik aurrera, asertzioetan erabiltzen ditugun terminoak eta
formulak ondo definituta daudela adierazteko def predikatua erabiliko dugu.
def predikatuak terminoak edo formulak har ditzake argumentu gisa, eta egiazko
balioa itzuliko du baldin eta soilik baldin argumentua (terminoa edo formula)
ondo definituta badago konputazio-egoera batean.
**** 2.2.4 Arrazonamendua ****
Esana dugu programak exekutatzen direnean aldagaien balioak aldatzen direla
esleipenen bidez. Egoera-aldaketa horiek asertzioetan jasotzen dira: asertzio
batek aldaketa aurreko egoera adieraziko du, eta beste batek aldaketa ondorengo
egoera. Asertzio batetik besterako trantsizio horiek, azken batean, logikan
oinarritutako arrazonamendua dute oinarrian. Komeni zaigu, bada, modu sendoan
egitea aldaketak eta horien inguruko arrazoiketak. Zeregin horretan erabiliko
dugun oinarrizko eragiketa ordezpena da. Funtsean, formula bateko aldagaien
ordez terminoak jartzea da ordezpenak egitea.
Hona hemen ordezpenaren definizio formala: izan bitez φ formula, x aldagaia eta
t terminoa, adierazpenak φ formulako x-ren agerpen libre guztien ordez t
terminoa jarrita lortzen den formula errepresentatzen du. Transformazio sinple
hori egitean bada kontuan hartu beharreko murriztapen bat: t terminoak ezin du
eduki φ formulan kuantifikatuta (atxikia) agertzen den aldagairik. Adibidez:
ez da zuzena.
Ondoren ikusiko dugu nola sinplifikatzen diren ordezpen batzuk:
•
•
•
Ordezpenaz gain, arrazonatzean garrantzi handikoa da formulen arteko ahulago-
gogorrago erlazioa. Formalki, φ formula ψ baino gogorragoa da (edo ψ φ baino
ahulagoa) baldin eta soilik baldin
{s|s(φ)=true}⊆{s|s(ψ)=true}
non {s|s(φ)=true} multzoa den φ formulak egiazko egiten dituen egoeren multzoa,
eta era berean {s|s(ψ)=true} multzoa ψ formulak errepresentatzen duen egoeren
multzoa.
Adibidez, φ≡lehena(x)∧x>3 formula ψ≡≠(xmod3=0) baino gogorragoa da:
Definizio horretatik zenbait propietate interesgarri ondoriozta daitezke:
•φ→ψ betetzen da baldin eta soilik baldin φ gogorragoa bada ψ baino (edo, beste
era batean esanda, ψ ahulagoa bada φ baino).
•true da formularik ahulena (egiazkoa baita edozein s egoeratan) eta false da
gogorrena (faltsua da-eta edozein s egoeratan).
Hortaz, betetzen da φ→true eta false→φ edozein φ formulatarako.
•φ→(φ∨ψ)
•(φ∧ψ)→φ
•Edozein φ-tarako, formula gogorragoa da ∃xφ baino, eta ahulagoa ∀xφ baino.
Adibide batzuen bidez ilustratuko dugu formula ahulago eta gogorragoen
kontzeptua:
•(x>0) gogorragoa da (x≥0) baino, zeren (x≥0)≡(x>0∨x=0) (gogoratu φ→(φ∨ψ)
betetzen dela).
•(x=0∧y=1) gogorragoa da baino.
•(k=0) eta (k=1∧A(1)=0) formulak gogorragoak dira
∀j(1≤j≤k→A(j)=0)
baino.
k=0 denean, kuantifikatzaile unibertsalaren domeinua hutsa da eta, ondorioz,
kuantifikazioaren balioa true da. Gogoratu: (k=0)→true
•lehena(2) formula gogorragoa da ∃x(lehena(x)) baino.
•(5≤n∧A(5)>0) eta (1≤i≤n∧A(i)>0) formulak gogorragoak dira ∃j(1≤j≤n∧A(j)>0)
baino.
•∀i(1≤i≤n→bikoiti(A(i))) formula gogorragoa da
(7≤n→bikoiti(A(7)))
baino.
•∀j(1≤j≤n→A(j)>0) formula gogorragoa da (1≤i≤n→A(i)>0) baino.
***** 2.3 Aurre-ondoetako espezifikazio formala *****
Aurreko atalean azaldu dugu zein lengoaia erabiliko dugun espezifikazioak modu
formalean adierazteko. Honako honetan, espezifikazioaren formatua deskribatuko
dugu.
Irakasgai honetan, aurre-ondoetako formatua erabiliko dugu
espezifikazioetarako. Formatu hau erabiliz, programak horrela espezifikatzen
dira
                                  {Φ} S {Ψ}
non S programa den, eta Φ eta Ψ asertzioak diren. Φ asertzioari aurreko
baldintza (edo aurre-baldintza) deitzen zaio, eta Ψ-ri ondoko baldintza (edo
post-baldintza). Kontuan hartu behar da programa programazio-lengoaian idatzita
dagoela, eta asertzioak, aldiz, logika-lengoaian. Gure kasuan, programazio-
lengoaia ADA da eta asertzioen lengoaia, lehen mailako logikaren lengoaia.
Esanahiaren aldetik, aurreko espezifikazioak adierazten du Φ betetzen den
egoera batean hasten bada S programa, orduan Ψ betetzen den egoera batean
bukatzen dela.
Aurreko baldintzak adierazten du zein egoeratan abia daitekeen S programa.
Horregatik, komeni da ahalik eta formula ahulena definitzea, nolabait, datuen
baldintza minimoak programaren exekuzioa zuzena izan dadin.
Aitzitik, post-baldintzak adierazten du datuen eta emaitzen arteko erlazioa
eta, horregatik, formularik gogorrena definitu behar da, ahalik eta modurik
zorrotzenean esateko zein diren emaitza onargarriak sarreren arabera.
Adibidez, zatidura eta hondar osoa kalkulatzen duen programaren aurre-ondoetako
espezifikazioa honako hau izan daiteke:
     Aurre ≡ {y>0∧x≥0}
     begin
      z := 0;
      h := x;
      whileh >= yloop
       z := z+1;
       h := h-y;
    end_loop;
 end;
 Post ≡ {x=z×y+h∧y>h≥0∧z≥0}


Aurre-ondoetako asertzio horiek espezifikazio egokia osatzen dute. Aurreko
baldintza aski ahula da datu onargarri guztiak onartzeko. Post-baldintza aski
gogorra da onartezinak liratekeen emaitzak bazter uzteko.
Aurre-baldintza adierazteko (y>1∧x≥0) erabili izan bagenu, gogorregia izango
litzateke, programak 1 zenbakiaren zatiketa osoa ere kalkulatzen duelako.
Bestetik, (≠y=0∧x≥0) erabili izan bagenu, ahulegia izango litzateke, aurre-
baldintzak onartu arren programak ez baitu ondo kalkulatzen zenbaki negatiboen
zatidura.
Era berean, post-baldintzari dagokionez, (x=z×y+h) formula ahulegia izango
litzateke. Erraz samar topa dezakegu egoera bat post-baldintza beteko lukeena
baina zatidura onargarritzat har ezin daitekeena. Esate baterako:
                             {x=31∧y=7∧z=3∧h=10}
Bestetik, (x=z×y+h∧h=y−1) gogorregia izango litzateke; kasu honetan badaude
egoera batzuk ({x=31∧y=7∧z=3∧h=10}, adibidez) post-baldintza beteko ez
luketenak, baina emaitza egokiak direnak.
                                      12
