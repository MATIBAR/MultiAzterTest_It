<?xml version="1.0" encoding="UTF-8"?>
5
Programa errekurtsiboen transformazioa:
Burstall-en metodoa
5.1 Burstall-en metodoa, programa errekurtsiboak
iteratibo bihurtzeko
Programa errekurtsiboak soluziorik zuzenena, sinpleena eta argiena izaten dira
zenbait
problematarako. Esate baterako:
• Indukzio bidez definitutako funtzioak.
• Datu-mota induktiboen tratamendua.
• Izaera bereko azpiproblematan banatzen diren problemak.
Baina askotan, batez ere programa iteratiboekin konparatuz, ez dira
eraginkorre-
nak. Eraginkor ez izate hori bi arrazoi hauengatik gertatzen da:
• Kalkuluen errepikapenagatik.
• Parametroak gorde eta berreskuratu behar direlako deiak kateatzean.
Hala ere, esan dugunez, zenbaitetan errazagoa da algoritmo errekurtsiboa gara-
tzea iteratiboa garatzea baino. Horregatik, oso interesgarria da ebazpide
errekurtsiboa
abiapuntu gisa erabiltzea programa iteratibo bat lortzeko, bereziki batetik
besterako
bihurketa era metodikoan egiten bada. Horrela jokatuz gero, ebazpide
eraginkorragoa
lor daiteke eta, era berean, azkeneko programa iteratiboaren zuzentasuna
justifikatuta
geratzen da.
Gainera, transformazio-eredu honen bidez sakonki azter daiteke
errekurtsibitatearen
eta iterazioaren arteko erlazioa.
Gai honetan, Burstall-en metodoa1 landuko dugu. Metodo honek funtzio errekur-
tsiboak iteratibo bihurtzeko balio du.
Honako hauek dira metodoaren oinarriak:
1. Abiapuntutzat, algoritmo errekurtsiboa edo zehaztapen induktiboa hartzen da.
2. Formulazio induktibo horri erreparatuta, soluzioaren errekurrentzia-erlazioa
ate-
ratzen da.
1 A Transformation System for Developing Recursive Programs. R.M Burstall and
J. Darlington.
In Journal of the ACM, Volume 24, Issue 1, pages 44-67. January 1977.
1
3. Errekurrentzia-erlazio hori izango da, hain zuzen ere, oraindik sortu gabe
da-
goen iterazioaren inbariantea. Iterazioaren borne-adierazpena ere pauso honetan
asmatzen da.
4. Inbariante hori oinarri hartuta, iterazioa edo algoritmo iteratiboa formalki
era-
tortzen da, honako urratsetan: hasieraketa, bukaerako tratamendua (emaitza) eta
iterazioaren gorputza.
Iterazioaren gorputza eratortzeko, definizio induktiboan eta inbariantean
oinarrituta,
destolesketa/tolesketa teknika erabiltzen da.
5.2 Metodoaren deskribapena
Esan bezala, Burstall-en metodo orokorra funtzio baten definizio
induktiboarekin has-
ten da
f : T1 × . . . × Tn → T
non T = T1 . . . Tn diren funtzioko parametro formalen motak, eta T den
emaitzaren
mota. x = x1 . . . xn deituko diegu parametro formalei (x1 ∈ T1 , . . . , xn ∈
Tn ). De-
finizio induktibo horretatik errekurrentzia-erlazio bat ateratzen da, eta
erlazio hori
inbariantetzat hartzen da. Honako hau izango da inbariantearen forma:
IN B ≡ f (x) = F (f (y), z)
non y eta z aldagai berriak diren, iterazioan erabiliko direnak. F funtzioaren
bidez
adierazten dugu f (y) eta z-ren arteko erlazioa, hasierako funtzioaren
definizio indukti-
botik asmatu behar duguna. Orokorrean, errekurrentzia erlazioak antz handia
hartzen
du kasu induktiboek bueltatzen duten emaitzarekin.
Borne-adierazpena y aldagaien gainean definituko da, eta iterazioak bukatzeko
falta
dituen pausoen kopurua mugatuko du.
Inbariante horretatik eratorriko den funtzio iteratiboak honako forma hartzen
du:
function f_it(x : T) return T’ is
y : T;
z : ?;
begin
- - Hasieraketa
while not bukbal(y) loop
INB ≡ { f (x) = F (f (y), z) }
- - Gorputza
E ≡ g(y)
(y,z) := (y’,z’);
end loop;
- - Emaitza
end f_it;
f _it funtzio iteratiboaren goi-burukoa f funtzio errekurtsiboaren berdina da:
pa-
rametro berdinak hartzen ditu (x) eta emaitza ere mota berekoa da. Hori bai, f
_it
funtzioak beste aldagai laguntzaile batzuk ere erabiltzen ditu: y eta z. x
parametroek
konputazio errekurtsiboan hartuko lituzketen balioak gordetzeko erabiltzen dira
y alda-
gaiak algoritmo iteratiboan, eta horregatik dira mota berekoak. z aldagaiak
informazio
osagarria gordetzeko erabiltzen dira.
Programaren lehenengo zatia hasieraketa da, eta bertan y eta z aldagaiak
hasieratu
behar dira inbariantea iteraziora sartzerako bete dadin.
2
Programaren bigarren zatia iterazioa bera da, non bukaera-baldintza (bukbal
fun-
tzioa) eta gorputza definitu behar diren. Bukaera-baldintza definitzeko,
hasierako al-
goritmo errekurtsiboko kasu nabariekin parekatzen dira iterazioko bukaera-
kasuak.
Oinarria sinplea da: iterazioa bukatuko da errekurtsioa bukatuko litzatekeen
egoera
berdinetan. Hori bai, kontuan hartu behar da errekurtsioaren bukaera x
parametroen
arabera formulatzen zela, eta iterazioan, berriz, y aldagaien arabera formulatu
behar-
ko da. Hortaz, bukbal funtzioa kasu nabari guztien baldintzen disjuntzioa
izango da.
Iterazioaren gorputzari dagokionez, irizpide nagusia honako hau da: iterazioko
pauso
bakoitzak dei errekurtsibo bat simulatu behar du. Nolabait, algoritmo
errekurtsiboaren
exekuzioan dei batetik bestera gertatzen ziren aldaketak izango dira y eta z
aldagaie-
tan jasoko direnak. Aldagai horiei, beraz, balio berriak esleitzen zaizkie
iterazio-pauso
bakoitzean. Metodoaren aplikazioan, balio berri horiek zaharretatik bereizteko
horrela
izendatuko dira: y eta z . Balio horiek destolesketa/tolesketa teknikaren bidez
lortzen
dira inbariantea oinarritzat hartuta eta kasu induktiboen arabera. Behin balio
berriak
zein izango diren erabakita, erraz asma daiteke gorputzaren kodea: azken
batean, y
eta z aldagaiei balio berriak esleitu beharko zaizkie. Asignazio horiek,
formalki, aldi
berean gertatzen dira eta (y, z) := (y , z ) notazioarekin adieraz daiteke aldi
berekoak
direla. Baina, ADAn asignazioak banan-banan egin beharra dagoenez, kontu handia
eduki behar da asignazioen hurrenkerarekin, eta batzuetan aldagai laguntzaileak
ere
erabili behar dira. Gainera, kasu induktibo bat baino gehiago dagoenean, kasu
ho-
rien araberako esleipen baldintzatuak egin behar izaten dira, eta horregatik,
if agindua
erabiltzen da.
Programaren azken zatian bukaerako tratamendua egiten da, hau da, azken emaitza
lortzea. Emaitza zein den kalkulatzeko inbariantearen ebaluazioa egiten da y
eta z
aldagaien balioekin (iteraziotik ateratakoan izango dituzten balioekin).
Honakoan ere,
kasu nabari bat baino gehiago badago, kasu horiek denak ondo tratatzeko if
agindu
bat erabiltzen da.
5.3 Metodoaren aplikazio-adibideak
Lehenengo adibidea zenbakien oinarri-aldaketa da. Izan bedi oinald(x, b)
funtzioa, x
zenbaki arruntaren b oinarriko errepresentazioa itzultzen duena:
oinald: Integer × Integer → sekuentzia(Integer)
Aurre: 1 < b < 10 ∧ x ≥ 0
x
baldin x < b
oinald(x, b) =
oinald(x/b, b)@ x mod b bestela
Definizio errekurtsibo hori programa iteratibo bihurtuko dugu.
1. Hasteko, errekurrentzia-erlazioa atera behar dugu. Helburu horretara
iristeko
hurbilpen egokia da destolesketa/tolesketa teknika erabiltzea adibide zehatz
ba-
ten gainean. Adibidez, oinald(123, 4) adibidea hartuko dugu, eta espresio
horren
kalkulua egingo dugu definizio induktiboak adierazitakoaren arabera. Kalkulu
horretan, destolesketa-urrats bakoitzean funtzioaren definizioa aplikatzen da
eta,
berriz, tolesketa-urrats bakoitzen, lortzen dugun adierazpena sinplifikatu
egiten
da.
oinald(123, 4) destolestuta oinald(30, 4)@ 3 lortzen dugu (oinald-en kasu in-
duktiboa), eta adierazpen hau ezin da sinplifikatu. Ondoren, beste
destolesketa-
urrats bat egingo dugu, orain oinald(30, 4)-ren gainean, eta oinald(7, 4)@ 2
ate-
ratzen da (kasu induktiboa). Adierazpen osoa (oinald(7, 4)@ 2 )@ 3 da eta,
3
sekuentzien kateaketa elkarkorra denez, sinplifika daiteke (tolesketa-urratsa):
oinald(7, 4)@ 2, 3 . Berriro beste destolesketa-urrats bat egingo da oinald(7,
4)-
ren gainean, eta, horrela, bukatu arte. Laburbilduz, destolesketa/tolesketa
tek-
nika erabiliz gelditzen den transformazioa horrelakoa da:
oinald(123, 4)
destolestu/tolestu
= oinald(30, 4) @ 3
destolestu
= (oinald(7, 4)@ 2 )@ 3
tolestu
= oinald(7, 4) @ 2, 3
destolestu
= (oinald(1, 4)@ 3 )@ 2, 3
tolestu
= oinald(1, 4) @ 3, 2, 3
destolestu
= 1 @ 3, 2, 3
tolestu
= 1, 3, 2, 3
Orain, transformazio hori aztertzen da errekurrentzia ateratzeko. Horretarako,
tolesketa-urrats guztien ondoren gelditzen den adierazpena kontuan hartzen du-
gu:
oinald(30, 4)@ 3
oinald(7, 4)@ 2, 3
oinald(1, 4)@ 3, 2, 3
1, 3, 2, 3
Azkena izan ezik, oso erraz ikus daiteke gelditzen den adierazpenaren forma
oro-
korra horrelakoa dela
oinald(x, b) = oinald(y, b)@S
non x, b eta y zenbaki arruntak diren, eta S zenbaki arrunten sekuentzia bat.
Hau da, hasierako espresioa beti da zenbaki baten oinarri-aldaketaren emaitza
zenbaki osokoen sekuentzia batekin kateatuta. Adierazpen hori da atera dugun
errekurrentzia-erlazioa eta hori izango da, hain zuzen, inbariantetzat hartuko
du-
guna. Garbi ikusten da inbariantea eta kasu induktiboaren emaitza oso antzekoak
direla.
Borne-adierazpena ere asma dezakegu egin dugun transformazioan oinarrituta.
Destolesketa/tolesketa prozesuan ikusi dugu y aldagaia gero eta txikiagoa
egiten
dela, harik eta b baino txikiagoa izan eta prozesua bukatu den arte. Borne-
adierazpena, hortaz, honako hau izan daiteke: E ≡ y
4
2. Ondoren, eta inbariantea abiapuntutzat hartuta, programa iteratiboaren atal
guztiak eratortzen dira:
• Hasieraketa. Ataza honek ziurtatu behar du inbariantea betetzen dela lehe-
nengo iterazioa egikaritu baino lehenago. Horretarako, pentsatu behar dugu
zein balio hartu behar duten y eta S aldagaiek
oinald(x, b) = oinald(y, b)@S
inbariantea betetzeko. Kasu honetan, soluziorik errazena honako hau da:
y := x;
S := <>;
• Bukaera-baldintza. Hasierako definizio induktiboan kasu nabari bakar bat
dago, x < b baldintzaren bidez adierazten dena. Iterazioan, hortaz, bukaera-
baldintza sinplea izango da, eta horrela formulatuko da: bukbal(y) ≡ y < b.
• Emaitza. Bukaera-baldintza bakarra dagoenez, emaitza ere modu bakunean
adieraz dezakegu (if aginduaren beharrik gabe). Inbariantean oinald(y, b)
adierazpena bere balioarekin ( y ) ordeztuta lortuko dugu emaitza:
y < b → oinald(x, b) = oinald(y, b)@S = y @S = y • S
Hau da, emaitza y • S da. ADAn adierazita:
return y • S;
• Iterazioaren gorputza. Inbariantea abiapuntu hartuta, destolesketa / toles-
keta teknika erabiliko dugu kasu induktibo bakarrarekin:
oinald(x, b)
= oinald(y, b) @S
destolestu
= (oinald(y/b, b)@ y mod b )@S
tolestu
= oinald( y/b ,b)@( y mod b @S)
= oinald( y , b)@
S
Hau da, iterazioen gorputza honako aldibereko asignazioa da:
(S,y) := (< y mod b > @ S,y/b);
Aldibereko asignazio anizkoitz honen asignazioak ezin daitezke edozein or-
denatan egin. S sekuentzia eguneratzeko erabiltzen den y aldagaiaren balioa
zaharra da, y eguneratu aurrekoa. Beraz, beharrezkoa da y eguneratu au-
rretik S eguneratzea:
S := < y mod b > @ S;
y := y/b;
Horrenbestez, metodoa aplikatuta lortu dugun funtzio iteratiboa honako hau da:
5
function oinald_it(x,b : Integer) return sekuentzia(Integer) is
y : Integer;
S : sekuentzia(Integer);
begin
{ 1 < b < 10 ∧ x ≥ 0 }
y := x;
S := <>;
INB ≡ { oinald(x, b) = oinald(y, b)@S }
while not y < b loop
E≡y
S := < y mod b > @ S;
y := y/b;
end loop;
return y • S;
end oinald_it;
{ oinald_it(x, b) = oinald(x, b) }
Ikusiko dugun bigarren adibidea sekuentzien nahasketa egitean datza. Adibide
ho-
netan deskribatzen da zer gertatzen den kasu induktiboetan erabiltzen diren
eragiketak
ez-elkarkorrak direnean.
Izan bedi nahastu funtzioa, non nahastu(S, R) adierazpenak S eta R sekuentzien
fusioa itzultzen duen:
nahastu: sekuentzia(T ) × sekuentzia(T ) → sekuentzia(T )
(1) nahastu( , R) = R
(2) nahastu(S, ) = S
(3) nahastu(x • S, y • R) =
x • nahastu(S, y • R) baldin x ≤ y
y • nahastu(x • S, R) bestela
Funtzio honek bi kasu nabari eta bi kasu induktibo ditu. Aplika dezagun
Burstall-
en metodoa, definizio induktibo horretatik funtzio iteratibo bat lortzeko.
1. Aurreko adibidean egin dugun bezalaxe, destolesketa/tolesketa teknika
erabiliko
dugu datu zehatz batzuen gainean errekurrentzia erlazioa ateratzeko. Baina,
adi-
bide honetan, datuak aukeratzean kasu induktibo guztiak gerta daitezen bilatuko
dugu. Esate baterako, nahastu( 1, 4, 6 , 2, 3 ) adibide on bat da, 1 (lehenengo
sekuentziako lehenengo osagaia) 2 (bigarren sekuentziako lehenengo osagaia)
bai-
no txikiagoa delako (lehenengo kasu induktiboa), eta 4 (lehenengo sekuentziako
bigarren osagaia) 2 baino handiagoa delako. Alegia, definizio induktiboaren
ara-
berako kalkuluan, bi kasu induktiboak gertatuko dira, eta horrek orokortasuna
ematen dio egindako transformazioari.
Hala bada, nahastu( 1, 4, 6 , 2, 3 ) destolestu ondoren 1 • nahastu( 4, 6 , 2,
3 )
lortzen dugu (funtzioaren lehenengo kasu induktiboa). Sinplifikatu ezin denez,
nahastu( 4, 6 , 2, 3 ) destolesten dugu, eta 2 • nahastu( 4, 6 , 3 ) lortzen
du-
gu. Adierazpen osoa 1 • (2 • nahastu( 4, 6 , 3 )) da, eta adierazpen hau ezin
da sinplifikatu • eragiketa erabiliz. Kontua da • ez-elkarkorra dela eta,
horre-
gatik, ezin ditugula 1, 2 eta nahastu( 4, 6 , 3 )) adierazpenak beste era
batean
•-ren bidez erlazionatu. Kasu hauetan, funtzio ez-elkarkorra beste funtzio
bate-
kin ordezkatzen da, elkarkorra dena. Sekuentziak osatzeko elkarkorra den fun-
tzio bat kateaketa (@) da eta, horren bidez, aurreko adierazpena toles daiteke:
1, 2 @nahastu( 4, 6 , 3 ). Hortaz, • funtzioa kateaketarekin (@) ordezkatuta,
destolesketa/tolesketa prozesu osoa horrela gelditzen da:
6
nahastu( 1, 4, 6 , 2, 3 )
destolestu
= 1 • nahastu( 4, 6 , 2, 3 )
tolestu
= 1 @ nahastu( 4, 6 , 2, 3 )
destolestu
= 1 @(2 • nahastu( 4, 6 , 3 ))
tolestu
= 1, 2 @ nahastu( 4, 6 , 3 )
destolestu
= 1, 2 @(3 • nahastu( 4, 6 ,
))
tolestu
= 1, 2, 3 @ nahastu( 4, 6 ,
)
destolestu
= 1, 2, 3 @ 4, 6
tolestu
= 1, 2, 3, 4, 6
Transformazio hori aztertu ondoren ateratzen den errekurrentzia-erlazioa honako
hau da
nahastu(S, R) = U @nahastu(V, W )
non S, R, U , V eta W zenbaki osokoen sekuentziak diren. U , V eta W aldagai
berriak dira. Ikus daitekeenez, kasu induktiboetan erabiltzen diren adierazpe-
netatik atera da errekurrentzia-erlazioa, • funtzioa kateaketarekin ordezkatuz.
Errekurrentzia-erlazio hori funtzio iteratiboaren inbariantea izango da.
Borne-adierazpenari dagokionez, esan dezakegu bukaerarako falta dena V eta W
sekuentzien luzeraren araberakoa dela. Aukera bat baino gehiago badaude ere,
borne-adierazpen egokia da honako hau: E ≡ luz(V ) + luz(W ), non luz(V ) eta
luz(W ) V eta W sekuentzien luzerak diren hurrenez hurren.
2. Ondoren, eta inbariantea ardatz hartuta, programa iteratiboaren zati guztiak
eratorriko ditugu:
• Hasieraketa. while-ra lehenengo aldiz iristean inbariantea bete dadin, hona-
ko asignazio hauek egin daitezke hasieran:
U := <>;
V := S;
W := R;
• Bukaera-baldintza. Bi kasu nabari daudenez, horiek ondo jasotzen dituen
bukaera-baldintza disjuntzio baten bidez adieraziko dugu, hasierako para-
metroen ordez iterazioko aldagaiak jarriz:
bukbal(V, W ) ≡ hutsa_da?(V ) ∨ hutsa_da?(W )
Iteraziotik aterako gara V edo W sekuentzia hutsa denean.
7
• Emaitza. Bukaera-baldintza bi kasuren disjuntzioa denez, kasu bakoitza-
ren emaitza era banatuan kalkulatuko dugu. Inbariantean nahastu(V, W )
adierazpenak duen balioa jarriko dugu kasu bakoitzean:
hutsa_da?(V ) → nahastu(S, R) = U @nahastu(V, W ) = U @W
hutsa_da?(W ) → nahastu(S, R) = U @nahastu(V, W ) = U @V
Hau da, emaitza U @W edo U @V izango da, bukaerako kasuaren arabera:
if hutsa_da?(V) then
return U @ W;
else
return U @ V;
end if;
• Iterazioaren gorputza. Inbariantea abiapuntu hartuta, destolesketa / toles-
keta teknika erabiliko dugu kasu induktibo bakoitzeko.
Lehenengo kasu induktiboa: lehena(V ) ≤ lehena(W )
nahastu(S, R)
= U @ nahastu(V, W )
destolestu
= U @(lehena(V )@nahastu(hondarra(V ), W ))
tolestu
=(U @ lehena(V ) )@nahastu(hondarra(V ), W )
U
=
@nahastu(
V ,
W )
Hau da, lehenengo kasu induktiboan iterazioaren gorputza honako aldibe-
reko asignazioa da:
(U,V,W) := (U @ < lehena(V) >,hondarra(V),W);
Aldibereko asignazio hau era bakar batean inplementa daiteke
U := U @ <lehena(V)>;
V := hondarra(V);
Izan ere, lehenago V := hondarra(V ); jarriko bagenu, orduan V sekuentzian
agertzen den lehenengo osagaia galdu egingo genuke.
Bigarren kasu induktiboa: lehena(V ) > lehena(W )
nahastu(S, R)
= U @ nahastu(V, W )
destolestu
= U @(lehena(W )@nahastu(V, hondarra(W )))
tolestu
=(U @ lehena(W ) )@nahastu( V, ,hondarra(W ))
=
U
@nahastu( V ,
Hortaz, aldibereko asignazioa honako hau da:
8
W )
(U,V,W) := (U @ <lehena(W)>,V,hondarra(W));
eta horrela inplementa daiteke:
U := U @ <lehena(W)>;
W := hondarra(W);
Bi kasuak bilduta, iterazioaren gorputza horrela gelditzen da:
if lehena(V) <= lehena(W) then
U := U @ <lehena(V)>;
V := hondarra(V);
else
U := U @ <lehena(W)>;
W := hondarra(W);
end if;
Lortu dugun funtzio iteratiboa honako hau da:
function nahastu_it(S,R : sekuentzia(T)) return sekuentzia(T) is
U,V,W : sekuentzia(T);
begin
U := <>;
V := S;
W := R;
INB ≡ { nahastu(S, R) = U @nahastu(V, W ) }
E ≡ luz(V)+luz(W)
while not ( hutsa_da?(V) or hutsa_da?(W) ) loop
if lehena(V) <= lehena(W) then
U := U @ <lehena(V)>;
V := hondarra(V);
else
U := U @ <lehena(W)>;
W := hondarra(W);
end if;
end loop;
if hutsa_da?(V) then
return U @ W;
else
return U @ V;
end if;
end nahastu_it;
{ nahastu_it(S, R) = nahastu(S, R) }
Hirugarren adibidea aztertuko dugu orain. Honako honetan errekurtsibitate aniz-
koitzeko definizio induktibo bat transformatu, eta iteratibo bihurtuko dugu.
Horreta-
rako, destolestean dei bat baino gehiago eduki behar dira kontuan. Gainera,
aztertu
behar da zein dei-konbinazio destolestu behar den, gero tolestu ahal izateko.
Izan bedi f ib funtzioa, non f ib(n) adierazpenak Fibonacci segidaren n-garren
zen-
bakia bueltatzen duen:
9
fib: Integer → Integer
Aurre: n ≥ 0
n
baldin n ≤ 1
f ib(n) =
f ib(n − 1) + f ib(n − 2) bestela
Funtzio honek kasu nabari bakar bat eta kasu induktibo bakar bat ditu, baina
kasu
induktiboan bi dei errekurtsibo erabiltzen dira.
1. Aurreko adibideetan bezalaxe, destolesketa/tolesketa teknika erabiliko dugu
erre-
kurrentzi erlazioa ateratzeko, baina, kasu honetan, bi dira landu beharreko dei
errekurtsiboak. Transformazioan estrategia hau erabiliko dugu: argumentu han-
diena duen deia destolestu.
f ib(5))
destolestu
= f ib(4) +f ib(3)
destolestu
= (f ib(3) + f ib(2)) + f ib(3)
tolestu
= 2 × f ib(3) +f ib(2)
destolestu
= 2 × (f ib(2) + f ib(1)) + f ib(2)
tolestu
= 3 × f ib(2) +2 × f ib(1)
destolestu
= 3 × (f ib(1) + f ib(0)) + 2 × f ib(1)
tolestu
= 5 × f ib(1) +3 × f ib(0)
destolestu
destolestu
=5×1+3×0
=5
Transformazio horri erreparatuta, errekurrentzia-erlazio bat baino gehiago asma
daiteke:
(1) f ib(n) = x × f ib(u) + y × f ib(v)
(2) f ib(n) = x × f ib(u) + y × f ib(u − 1)
(3) f ib(n) = x × f ib(v + 1) + y × f ib(v)
Azken errekurrentzia-erlazioa hartuko dugu inbariantetzat:
IN B ≡ f ib(n) = x × f ib(v + 1) + y × f ib(v)
Borne-adierazpena: E ≡ v
10
2. Inbariantea ardatz hartuta eratorriko ditugu programa iteratiboaren atal
guztiak.
• Hasieraketa. Inbariantea hasieran bete dadin, honako asignazio hauek erabil
daitezke:
x := 0;
y := 1;
v := n;
• Bukaera-baldintza. Kasu nabari bakar bat dagoenez, bukaera-baldintza sin-
plea da:
bukbal(v) ≡ v = 0
• Emaitza. Kasu nabaria v = 0 da. Inbariantean f ib(v + 1) eta f ib(v) adie-
razpenak beren une horretako balioarekin ordezkatuko ditugu:
v = 0 → f ib(n) = x × f ib(v + 1) + y × f ib(v) = x × 1 + y × 0 = x
Hau da, emaitza x da:
return x;
• Iterazioaren gorputza. Inbariantea oinarritzat hartuta, destolesketa / toles-
keta teknika erabiliko dugu:
f ib(n)
= x × f ib(v + 1) +y × f ib(v)
destolestu
= x × (f ib(v) + f ib(v − 1)) + y × f ib(v)
tolestu
=(x + y)×f ib(
=
x
v
)+ x ×f ib(v − 1)
×f ib( v + 1 )+ y ×f ib( v )
Hortaz, iterazioaren gorputza honako aldibereko asignazioa da:
(x,y,v) := (x+y,x,v-1);
Aldibereko asignazio hau inplementatzeko, aldagai laguntzaile bat erabili
behar dugu:
lag := x;
x := x+y;
y := lag;
v := v-1;
Horrenbestez, urrats guztiak bildurik, hona hemen lortu dugun funtzio
iteratiboa:
11
function fib_it(n : Integer) return Integer is
x,y,v,lag : Integer;
begin
{n≥0}
x := 0;
y := 1;
v := n;
INB ≡ { f ib(n) = x × f ib(v + 1) + y × f ib(v) }
while not v = 0 loop
E≡v
lag := x;
x := x+y;
y := lag;
v := v-1;
end loop;
return x;
end fib_it;
{ f ib_it(n) = f ib(n) }
12
