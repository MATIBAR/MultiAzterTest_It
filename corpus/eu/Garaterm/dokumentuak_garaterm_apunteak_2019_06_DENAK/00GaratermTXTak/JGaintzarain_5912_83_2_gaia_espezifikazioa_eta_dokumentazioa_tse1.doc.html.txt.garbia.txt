          Kudeaketaren eta Informazio Sistemen Informatikaren Ingeniaritzako Gradua                             Bilboko Ingeniaritza Eskola                                    UPV / EHU                     Lengoaiak eta Sistema Informatikoak Saila                              PROGRAMAZIOAREN_METODOLOGIA                                      1._maila                                        2. gaia                   Programen espezifikazioa eta dokumentazioa                                            2._gaia                   Programen_espezifikazioa_eta_dokumentazioa   2.1._Sarrera_5 2.1.1._Helburua_5 2.1.2._Espezifikazioaren_definizioa_5 2.1.3._Programen_zuzentasuna_5 2.2._Aurre-ondoetako_espezifikazioa_6 2.2.1._Aurreko_baldintza_eta_ondorengo_baldintza_6 2.2.2._Kontratu_bidezko_garapena_7 2.2.3._Adibide_gehiago_7 2.3._Lehen_Mailako_Logikaren_Lengoaia_9 2.3.1._Alfabetoa_9 2.3.2._Sintaxia_9 2.3.2.1._Terminoak_9 2.3.2.2._Formulak_10 2.3.3._Semantika_10 2.3.3.1._Ø,_Ù,_Ú,_®_eta_«_eragile_logikoen_semantika_10 2.3.3.2._$_zenbatzaile_existentzialaren_semantika_11 2.3.3.3._"_zenbatzaile_unibertsalaren_semantika_13 2.3.3.4._S_funtzioaren_semantika_15 2.3.3.5.__funtzioaren_semantika_16 2.3.3.6._N_funtzioaren_semantika_17 2.3.4._Aldagai_askeak_eta_aldagai_lotuak_19 2.3.5._Predikatu_berrien_definizioa_20 2.3.5.1._Predikatuen_definizioa_formulen_bidez_20 2.3.5.2._Formula_bati_dagokion_predikatua_22 2.3.5.3._Predikatu_berriak_nola_definitu_beste_predikatu_batzuk_erabiliz_23 2.4._Programen_espezifikazioa:_Adibideak_24 2.4.1._A(1..n)_bektoreko_elementuen_batura_s_aldagaian_kalkulatzen_duen programa_24 2.4.2._B(1..n)_bektorean_A(1..n)_bektorearen_kopia_bat_sortzen_duen_programa_ (1._bertsioa)_25 2.4.3._B(1..n)_bektorean_A(1..n)_bektorearen_kopia_bat_sortzen_duen_programa_ (2._bertsioa)_25 2.4.4._B(1..n)_bektorean_A(1..n)_bektorearen_kopia_bat_sortzen_duen_programa_ (3._bertsioa)_26 2.4.5._B(1..n)_taulan_A(1..n)_taulako_elementuak_posizio_bat_ezkerrera_biratuta gordetzen_dituen_programa_27 2.4.6._A(1..n)_bektoreko_elementuak_A(1..n)_bektorean_bertan_ezkerrera_biratzen dituen_programa_28 2.4.7._c_aldagaian_A(1..n)_taulako_zero-kopurua_kalkulatzen_duen_programa_(1. bertsioa)_29 2.4.8._c_aldagaian_A(1..n)_taulako_zero-kopurua_kalkulatzen_duen_programa_(2. bertsioa)_29 2.4.9._b_aldagaian_A(1..n)_taulan_zerorik_agertzen_al_den_ala_ez_erabakitzen duen_programa_30 2.4.10._b_aldagaian_A(1..n)_taulako_bikoiti-kopurua_bakoiti-kopurua_baino handiagoa_al_den_erabakitzen_duen_programa_30 2.4.11._x_balioa_A(1..n)_bektorean_agertzen_dela_jakinda,_bere_lehenengo agerpenaren_posizioa_pos_aldagaian_kalkulatzen_duen_programa_31 2.4.12._x_balioa_A(1..n)_bektorean_agertzen_bada_pos-en_bere_lehenengo agerpenaren_posizioa_eta_bestela_n_+_1_balioa_itzultzen_duen_programa_32 2.5._Programen_dokumentazioa:_jarraitu_beharreko_ideia_33 2.6._Programen_dokumentazioa:_Adibideak_34 2.6.1._B(1..n)_bektorean_A(1..n)_bektoreko_elementuak_x_balioaz_biderkatuta gordetzen_dituen_programa_(1._bertsioa)_34 2.6.2._B(1..n)_bektorean_A(1..n)_bektoreko_elementuak_x_balioaz_biderkatuta gordetzen_dituen_programa_(2._bertsioa)_36 2.6.3._B(1..n)_bektorean_A(1..n)_bektoreko_elementuak_x_balioaz_biderkatuta gordetzen_dituen_programa_(3._bertsioa)_38 2.6.4._B(1..n)_bektorean_A(1..n)_bektoreko_elementuak_x_balioaz_biderkatuta gordetzen_dituen_programa_(4._bertsioa)_40 2.6.5._A(1..n)_bektoreko_elementuak_x_balioaz_biderkatzen_dituen_programa_42 2.6.6._A(1..n)_bektoreko_elementuen_batura_s_aldagaian_kalkulatzen_duen programa_(1._bertsioa)_44 2.6.7._A(1..n)_bektoreko_elementuen_batura_s_aldagaian_kalkulatzen_duen programa_(2._bertsioa)_46 2.6.8._B(1..n)_bektorean_A(1..n)_bektorearen_kopia_bat_sortzen_duen_programa (ezkerretik_eskuinera_zeharkatuz)_(1._bertsioa)_50 2.6.9._B(1..n)_bektorean_A(1..n)_bektorearen_kopia_bat_sortzen_duen_programa_ (ezkerretik_eskuinera_zeharkatuz)_(2._bertsioa)_52 2.6.10._B(1..n)_bektorean_A(1..n)_bektorearen_kopia_bat_sortzen_duen_programa_ (eskuinetik_ezkerrera_zeharkatuz)_(1._bertsioa)_54 2.6.11._B(1..n)_bektorean_A(1..n)_bektorearen_kopia_bat_sortzen_duen_programa (eskuinetik_ezkerrera_zeharkatuz)_(2._bertsioa)_56 2.6.12._B(1..n)_taulan_A(1..n)_taulako_elementuak_posizio_bat_ezkerrera biratuta_gordetzen_dituen_programa_58 2.6.13._A(1..n)_bektoreko_elementuak_A(1..n)_bektorean_bertan_ezkerrera biratzen_dituen_programa_60 2.6.14._c_aldagaian_A(1..n)_taulako_zero-kopurua_kalkulatzen_duen_programa_(1. bertsioa)_63 2.6.15._c_aldagaian_A(1..n)_taulako_zero-kopurua_kalkulatzen_duen_programa_(2. bertsioa)_66 2.6.16._b_aldagaian_A(1..n)_taulan_zerorik_agertzen_al_den_ala_ez_erabakitzen duen_programa_(1._bertsioa)_68 2.6.17._b_aldagaian_A(1..n)_taulan_zerorik_agertzen_al_den_ala_ez_erabakitzen duen_programa_(2._bertsioa)_70 2.6.18._b_aldagaian_A(1..n)_taulako_bikoiti-kopurua_bakoiti-kopurua_baino handiagoa_al_den_erabakitzen_duen_programa_73 2.6.19._x_balioa_A(1..n)_bektorean_agertzen_dela_jakinda,_bere_lehenengo agerpenaren_posizioa_pos_aldagaian_kalkulatzen_duen_programa_76 2.6.20._(2006_#1_-_Partziala)_79 2.6.21._(2006_#2_-_Partziala)_82   2.1._Sarrera  2.1.1. Helburua Programa bat garatzerakoan oso garrantzitsua da programak zer egin behar duen ondo zehaztea.  Programa batek zer egin behar duen adierazteko edo espezifikatzeko espezifikazio-lengoaia formal bat erabili behar da.  Espezifikazio-lengoaia formal bat erabiliz ez da anbiguotasunik egongo.  Gai honetako lehenengo helburua Lehen Mailako Logikaren lengoaia eta aurre- ondoetako espezifikazioa bezala ezagutzen den teknika erabiliz programak espezifikatzen ikastea da.  Bigarren helburua Lehen Mailako Logikaren lengoaia erabiliz programak dokumentatzea da, programen puntu desberdinetan betetzen diren propietateak azalduz.  2.1.2. Espezifikazioaren definizioa "Espezifikazioa" kontzeptuaren definizioa agertzen da jarraian:      * Sistema baten ezaugarriak eta portaera era zehatzean adierazten duen       dokumentua.  2.1.3. Programen zuzentasuna Programa edo algoritmo bat zuzena al den jakiteko, programaren sarrerako datuak kontuan hartuz irteerako emaitzek zein baldintza bete beharko lituzketeen espezifikatu beharko da era zehatzean.  Programa bat zuzena izango da programak egiten duena eta egin beharko lukeena (espezifikazioa) bat datozenean.     2.2._Aurre-ondoetako_espezifikazioa  2.2.1. Aurreko baldintza eta ondorengo baldintza Programa batek zer egin beharko lukeen adierazteko aurre-ondoetako espezifikazioa erabiliko dugu.  Aurre-ondoetako espezifikazio batean programa exekutatzen hasi aurretik_bete beharreko_baldintza eta programa exekutatu ondoren_bete_beharreko_baldintza edukiko ditugu.  Aurrebaldintzaren bidez sarrerako datuek bete beharko dituzten baldintzak zehazten dira. Programa exekutatzen hasi baino lehenago sarrerako datuek aurreko_baldintza (edo hasierako baldintza) bete behar dute.  Ondorengo baldintzaren bidez sarrerako datuen eta emaitzen arteko erlazioa zehaztuko da. Programaren exekuzioa bukatutakoan emaitzek ondorengo_baldintza (edo bukaerako baldintza) bete beharko dute.  Aurre-ondoetako espezifikazio baten esanahia honako hau da: sarrerako datuek aurreko_baldintza betetzen dutela suposatuz, programa exekutatutakoan emaitzek ondorengo_baldintza bete beharko dute.  1. Adibidea:        Aurrebaldintza  {x³9}       x : = x + 5;       Ondorengo baldintza  {x³14}  Espezifikazio horren arabera, esleipenaren aurretik x-ren balioa 9 baino handiagoa edo berdina bada, esleipenaren ondoren x-ren balioa 14 baino handiagoa edo berdina izango da.  2. Adibidea: Zenbaki osoz osatutako A(1..n) array baten elementuen batura s aldagaian lortzen duen programari dagokion aurre-ondoetako espezifikazioa honako hau da:        Aurrebaldintza  {n³1}       i : = 0; s : = 0;       while i < n loop       i : = i + 1;       s : = s + A(i);       end loop;       Ondorengo baldintza  {s =   tartean ez da x agertu:  (3)  {(1  i  n + 1)  k(1 £ k £ i – 2  A(k)  x)   (segi  A(i – 1)  x)}  segi aldagaiak true balio badu, ez dakigu A(i) balioa x-en berdina al den ala ez oraindik ez baita i posizioa aztertu.      * (4) puntuko asertzioa inbariantetik abiatuz kalkulatuko da. (4) puntuan       gaudenean badakigu while-aren baldintza bete egin dela eta ondorioz       badakigu i-ren balioa n + 1 baino txikiagoa dela eta "segi" aldagaiaren       balioa true dela. Horiek dira hain zuzen ere (4) puntuaren eta (3)       puntuaren arteko desberdintasunak.  (4)  {(1  i  n)  k(1 £ k £ i – 1  A(k)  x)  segi}      * (5) puntuko asertzioa (4) puntuko asertziotik abiatuz eta i posizioko       elementua x dela baina segi aldagaia oraindik ez dela eguneratu kontuan       hartuz kalkulatuko da.  (5)  {(1  i  n)  k(1 £ k £ i – 1  A(k)  x)  segi  A(i) = x}      * (6) puntuko asertzioa (4) puntuko asertziotik abiatuz kalkulatuko da,       izan ere (6) puntuan ez dakigu ez dakigu i posizioan x al dagoen ala ez.       Baina badakigu "segi" aldagaia eguneratuta dagoela. Beraz konparatutako       elementuak 1 eta i-ren artekoak dira.  (6)  {(1  i  n)  k(1 £ k £ i – 1  A(k)  x)  (segi  A(i)  x)}      * Amaitzeko E espresioa eman behar da. Inbariantea betetzen den puntuan,       hau da, (3) puntuan gauden bakoitzean, E espresioak gehienez zenbat       buelta gelditzen diren adierazi behar du. Bektore bat ezkerretik       eskuinera zeharkatzen ari garenean E espresioa "i aldagaiak hartuko duen       azkeneko balioa ken i" izaten da. Beraz kasu honetan E = n + 1 – i.       Bektore osoa zeharkatu baino lehen buka daitekeenez while-a, gehienez       zenbat buelta gelditzen diren adierazten digu E espresioak.  Adibide honetan segi eta i aldagaiak bukaerako emaitza kalkulatzeko prozesuan garrantzitsuak dira baina segi eta i emaitzak ez direnez bukaerako baldintzan ez dira agertzen. Bestalde pos aldagaia bukaerako baldintzan bakarrik agertzen da while-aren barruan ez baita erabili.    2.6.20. (2006 #1 - Partziala)      1. C(1..r) bektoreko elementu denak positiboak (> 0) direla adierazten       duenpositiboak(C(1..r))izeneko predikatua definitu.    2. C(1..r) bektorean z elementua agertzen den posizioetan D(1..r) bektoreak       0 balioa duela eta beste posizioetan bektore bietan elementu berdinak       daudela dierazten duenanulatuta(z, C(1..r), D(1..r))izeneko predikatua       definitu.  1. adibidea z balioa 8 dela kontsideratuz, adibide honetako C(1..6) eta D(1..6) bektoreentzat predikatua bete egiten da:       C(1..6)         2         8         1         15         20         8                      1         2         3         4          5          6       D(1..6)         2         0         1         15         20         0                      1         2         3         4          5          6  2. adibidea z balioa 15 dela kontsideratuz, adibide honetako C(1..6) eta D(1..6) bektoreentzat predikatua ez da betetzen:      C(1..6)         2         8         1         15         20         8                      1         2         3         4          5          6       D(1..6)         2         8         6         15         20         0                      1         2         3         4          5          6     1. C(1..r) bektorean z elementua v aldiz agertzen dela adierazten duenaldiz       (C(1..r), z, v)izeneko predikatua definitu.     1. x zenbaki osoa eta 0 baino handiagoak diren balioz osatutako A(1..n)       bektorea emanda, p aldagaian x balioa A(1..n) bektorean zenbat aldiz       agertzen den kalkulatu eta x balioaren ordez 0 balioa ipiniz B(1..n)       bektorean A(1..n) bektorearen kopia bat sortzen duen programa dokumentatu       zehaztutako puntuetako asertzioak idatziz. Asertzioak idazterakoan       aurreko ataletako predikatuak erabili behar dira.                       (1) {Hasierako baldintza}                      i : = 1;                      p : = 0;                      while(2) {Inbariantea} in + 1loop                      (3) {Tarteko asertzioa}                      ifA(i) = xthen(4) {Tarteko asertzioa}                      B(i) : = 0;                      (5) {Tarteko asertzioa}                      p : = p + 1;                      else(6) {Tarteko asertzioa}                      B(i) : = A(i);                      endif;                      (7) {Tarteko asertzioa}                      i : = i + 1;                      endloop;                      (8) {Bukaerako baldintza}                      (9) {E espresioa}   Soluzioa:     1. positiboak(C(1..r))  {i (1  i  r  C(i) > 0)}     1. anulatuta(z, C(1..r), D(1..r))  {i ((1  i  r  C(i) = z)  D(i) = 0)         i ((1  i  r  C(i)  z)  D(i) = C(i))}     1. aldiz(C(1..r), z, v)  {v = Ni (1  i  r  C(i) > 0)}     1. Lehenengo hasierako baldintza, bukaerako baldintza eta inbariantea emango       dira:  (1) {n  1  positiboak(A(1..n))} (8) {aldiz(A(1..n), x, p)  anulatuta(x, A(1..n), B(1..n))} (2) {1  i  n + 1  aldiz(A(1..i – 1), x, p)  anulatuta(x, A(1..i – 1), B(1..i – 1))}  Jarraian while-aren barruan dauden asertzioak emango dira. Horretarako inbariantetik abiatuko gara eta puntu bakoitzean inbariantearekiko zer aldatu den zehaztu beharo da:  (3) {1  i  n  aldiz(A(1..i – 1), x, p)  anulatuta(x, A(1.. i – 1), B(1..i – 1))}  (3) zenbakia dagoen lekuan badakigu while-an sartu garela eta beraz while-ko baldintza bete egin dela. Hori dela eta, orain badakigu i  n dela eta hori izango da (3) puntuan (2) puntuarekiko aldatzen dena.  (4) {1  i  n  aldiz(A(1..i – 1), x, p)  anulatuta(x, A(1..i – 1), B(1..i – 1))  A(i) = x}  (4) zenbakia dagoen lekuan gaudenean badakigu if aginduko then kasuan sartu garela eta beraz if-eko baldintza bete egin dela. Ondorioz puntu horretan A(i) = x beteko da eta hori da (4) puntuan (3) puntuarekiko aldatzen dena. Kasu honetan gauza bera adierazteko beste era bat ere badago:  {1  i  n  aldiz(A(1..i), x, p + 1)  anulatuta(x, A(1..i – 1), B(1..i – 1))}  Bigarren bertsio hau lehenengoa baino hobea da.  (5) {1  i  n  aldiz(A(1..i), x, p + 1)  anulatuta(x, A(1..i), B(1..i))}  (5) zenbakia dagoen lekuan gaudenean badakigu if aginduko then kasuan sartu garela eta gainera B taulako i posizioa eguneratu egin dela . (5) puntuko asertzioa (4) puntuko asertzioaren bigarren bertsioa eguneratuz lortu da.  (6) {1  i  n  aldiz(A(1..i), x, p)  anulatuta(x, A(1..i – 1), B(1..i – 1))}  (6) zenbakia dagoen lekuan gaudenean badakigu if aginduaren else kasuan sartu garela baina oraindik B taulako i posizioa ez dela eguneratu. (6) puntuko asertzioa (3) puntuko asertzioa aldatuz lortu da (3) puntukoa baita bere aurreko asertzioa, izan ere (3) puntuan gaudenean if aginduko baldintzaren arabera (4) puntura edo (6) puntura goaz. Kasu honetan x balioa A(i)-ren desberdina denez p ez da eguneratu behar, edo hobeto esanda, p dagoeneko eguneratuta dago eta x balioa i posiziora arte (i bera ere barne) zenbat aldiz agertzen den adierazten du, eta hori da (3) puntuko asertzioarekiko aldatu dena.  (7) {1  i  n  aldiz(A(1..i), x, p)  anulatuta(x, A(1..i), B(1..i))}  (7) puntuan ez dakigu if-aren then kasutik edo else kasutik joan garen baina badakigu B(i) eta p eguneratuta daudela eta A taula i posizioraino (i posiozioa barne) aztertuta dagoela.  Bukatzeko E espresioa emango da:  (9) {E = n + 1 – i} Inbariantea betetzen den puntuan gaudenean E espresioak zenbat buelta falta diren adieraziko digu era zehatzean.    2.6.21. (2006 #2 - Partziala)     1. x bikoitia dela adierazten duenbikoitia(x)izeneko predikatua definitu.     1. C(1..r) taulan 1 eta x – 1 posizioen artean (biak barne) dauden balio       denak bikoitiak direla eta z eta r-ren artean daudenak (biak barne)       bakoitiak direla adierazten duenpartizioa(C(1..r), x, z)izeneko       predikatua definitu. Aurreko ataleko predikatua erabili behar da.     1. C(1..r) bektorea (c1, c2, …, cr) bektorearen permutazio bat dela       adierazten duenperm(C(1..r), (c1, c2, …, cr))izeneko predikatua definitu.       C(1..r) bektorea (c1, c2, …, cr) bektorearen permutazioa izateak C-ko       elementu bakoitza C-n eta (c1, c2, …, cr) bektorean kopuru berean       agertzen dela esan nahi du.  1. adibidea Adibide honetako C(1..6) bektorea (2, 8, 1, 15, 20, 8) bektorearen permutazioa da:       C(1..6)         2         20         1         8         8         15                      1         2          3         4         5         6  2. adibidea Adibide honetako C(1..6) bektorea ez da (2, 8, 1, 15, 20, 8) bektorearen permutazioa:       C(1..6)         15         1         1         8         2         20                      1          2         3         4         5         6     1. Zenbaki osoz osatutako A(1..n) bektorea emanda, elementu bikoiti denak A       (1..n)-ko ezkerreko aldean eta bakoiti denak eskuineko aldean ipini eta p       aldagai boolearrean A(1..n)-ko elementuetatik gutxienez erdiak bikoitiak       al diren erabakitzen duen programa dokumentatu zehaztutako puntuetako       asertzioak idatziz. Asertzioak idazterakoan aurreko ataletako predikatuak       erabili behar dira.          {Hasierako baldintza}{A(1..n) =(a1, a2, …, an)n ≥ 1}         i : = 1;         k : = n + 1;         while(1) {Inbariantea} ikloop         (2) {Tarteko asertzioa}         ifA(i)mod20then(3) {Tarteko asertzioa}         lag : = A(i);         (4) {Tarteko asertzioa}         A(i) : = A(k – 1);         A(k – 1) : = lag;         (5) {Tarteko asertzioa}         k : = k – 1;         else(6) {Tarteko asertzioa}         i : = i + 1;         endif;         endloop;         (7) {Tarteko asertzioa}         p : = ((i – 1) > n / 2);         (8) {Bukaerako baldintza}         (9) {E espresioa}   Soluzioa:     1. bikoitia(x)  {x mod 2 = 0}     1. partizioa(C(1..r), x, z)  {i (1  i  x – 1  bikoitia(C(i)))   i (z  i  r  bikoitia(C(i)))}     1. perm(C(1..r), (c1, c2, …, cr))   {i (1  i  r  Nj (1  j  r  C(i) = C(j)) = Nk (1  k  r  C(i) = ck))     1. Hasteko hasierako_baldintza, bukaerako_baldintza (8), while-aren_ondoren       dagoen_asertzioa (7) eta inbariantea (1) eman beharko dira. Kasu honetan       hasierako baldintza enuntziatuan emana dator eta ondorioz beste hirurak       eman beharko dira:  (8) {perm(A(1..n), (a1, a2, …, an))  j (1  j  n + 1  partizioa(A(1..n), j, j))  p  (Nj (1  j  n  bikoitia(A(j))) > (n / 2))}  (7) {(1  i  n + 1)  perm(A(1..n), (a1, a2, …, an))  partizioa(A(1..n), i, i)}  (1) {(1  i  k  n + 1)  perm(A(1..n), (a1, a2, …, an))  partizioa(A(1..n), i, k)}  Jarraian while-aren barruan dauden asetzioak emango dira. While-aren barruko asertzioak ematerakoan inbariantearekiko edo asertzio bakoitzaren aurreko asertzioarekiko zer aldatzen den zehaztu beharko da:  (2) {(1  i < k  n + 1)  perm(A(1..n), (a1, a2, …, an))  partizioa(A(1..n), i, k)}  (2) zenbakiari dagokion lekuan gaudenean badakigu while-ean sartu garela eta beraz baldintza bete egin dela. Ondorioz i  k betetzen dela ziurtatu dezakegu eta hori da (2) puntuan (1) puntuarekiko aldatzen dena.  (3) {(1  i < k  n + 1)  perm(A(1..n), (a1, a2, …, an))  partizioa(A(1..n), i, k)  bikoitia(A(i))}  (3) zenbakiari dagokion puntuan gaudenean badakigu if-eko then kasuan sartu garela eta if-eko baldintza bete egiten dela. Beraz badakigu A(i) ez dela bikoitia eta hori da (3) puntuan (2) puntuan esaten denari gehitu diezaiokeguna.  (4) {(1  i < k  n + 1)  perm(A(1..n), (a1, a2, …, an))  partizioa(A(1..n), i, k)  bikoitia(A(i)) lag = A(i)}  (4) puntuan gaudenean badakigu if-eko then kasutik joan garela eta lag aldagaiari A(i) esleitu zaiola. Beraz (4) puntuko asertzioa (3) puntuko asertzioari informazio hori gehituz lortu da.  (5) {(1  i < k  n + 1)  perm(A(1..n), (a1, a2, …, an))  partizioa(A(1..n), i, k – 1)}  (5) zenbakia dagoen lekuan gaudenean badakigu if-eko else kasuan sartu garela eta i eta k – 1 posizioetako balioak trukatu egin direla baina momentuz i eta k-ren balioak ez dira eguneratu. (5) puntuko asertzioa (4) puntuko asertzioa aldatuz lortu da eta egindako aldaketa elementu bakoitiak k – 1 posiziotik aurrera daudela esatea izan da.  (6) {(1  i < k  n + 1)  perm(A(1..n), (a1, a2, …, an))  partizioa(A(1..n), i + 1, k)}  (6) zenbakiari dagokion puntuan gaudenean badakigu i posizioko elementua bikoitia dela eta ez dela mugitu behar, egin beharreko bakarra i aldagaia eguneratzea izango da baina momentuz i aldagaia ez denez eguneratu, (6) puntuko asertzioan elementu bikoitia i posizioraino iristen direla esan beharko da. Asertzio hori (2) puntuko asertzioa aldatuz lortu da, (2) puntukoa baita bere aurreko asertzioa.  Bukatzeko E espresioa emango da:  (9) {E = k – i} Adibide honetan ere inbariantea betetzen den puntuan gauden bakoitzean E espresioak zenbat buelta falta diren adieraziko digu era zehatzean.    1  
