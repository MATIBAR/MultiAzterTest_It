   1. Kapitulua Errorea eta algoritmoen ezaugarriak 1.1 Errorearen jatorriak • Problemaren planteamenduan • problemaren modelizazioa • datu ﬁsikoak • Zenbakizko ebazpenean • motze-errorea • borobiltze-errorea 1.1.1 motze-errorea 1.1 Adibidea. f (x) = sin x funtzioaren Taylor garapena zera da: sin x = ∞ i =0 (−1) i x2i+1 (2i + 1)! = x − x3 3! + x5 5! − x7 7! + . . . Praktikan, seriea moztu behar dugu batugai kopuru ﬁnitu bat batzeko. Demagun n-garren batugaian gelditzen garela, honako polinomio hau sortuz: pn(x) = x − x3 3! + x5 5! − · · · + (−1) n x2n+1 (2n + 1)! 3  4 1. Kapitulua Errorea eta algoritmoen ezaugarriak p(x) = sin x denez, egin dugun motze errorea zera da: et = sin x − pn(x) . 1.2 Adibidea. Demagun f :   −→R funtzio integragarri bat dela. Izan bedi I(f ) = 1 0 f (x) dx I(f ) balioaren hurbilpen bat kalkula daiteke Riemann baturak erabiliz. f - ren graﬁkoak eta ardatzak mugatzen duten azaleraren balioa hurbildu daiteke n laukizuzen erabi- liz, Q(f ) haien azaleren batura izanik: Q(f ) = 1 n f (0) + f (1/n) 2 + f (1/n) + f (2/n) 2 + · · · + f ((n − 1)/n) + f(1) 2 . Egindako motze-errorea: et = I(f ) − Q(f) 1.1.2 Borobiltze errorea Ordenagailu bat erabiltzen badugu aurreko adibideko Q(f ) kalkulatzeko, beraz, makina-zenbakiak erabiltzeagatik, hau da, hamartar kopurua mugatuta egonik, ez dugu Q(f ) balioa lortuko, baizik eta Q (f ) beste balio bat. Egindako borobiltze- errorea zera da: er = Q(f ) − Q(f). 1.1.3 Errore totala Aurreko adibideko integralaren balioari ordenagailuz lortzen dugun balioa kentzen badiogu, errore totala lortzen dugu: e = I(f ) − Q(f) = I(f ) − Q(f) + Q(f) − Q(f) = et + er 1.1.4 Hasierako errorea Demagun sin √ 3 kalkulatu nahi dugula pn Taylor polinomioa erabiliz, eta kalkulu- rako, √ 3 ≈ 1.7 hartzen dugula. Hasierako errore bat eragiten du hurbilketa honek: ei = pn( √ 3) − pn(1.7)  1.2. Errore absolutu eta erlatiboa 5 Kasu honetan, errore guztiak metatzen dira errore totalean: e = sin √ 3 − pn(1.7) = sin √ 3 − pn( √ 3) + pn( √ 3) − pn(1.7) + pn(1.7) − pn(1.7) = et + ei + er. 1.2 Errore absolutu eta erlatiboa 1.1 Deﬁnizioa. Benetazko balio bat eta bere hurbilketa baten arteko diferentziari errore absolutu esaten zaio, eta honela idatziko da: e = x − ¯x, benetazko balioa eta hurbilketa x eta ¯ x izanik, hurrenez hurren. Balio negatiboak ekiditzeko, ohikoa da balio absolutua hartzea, hau da: e = |x − ¯x|. 1.2 Deﬁnizioa. Errore absolutua eta benetazko balioaren arteko zatidurari errore erlatibo esaten zaio, eta honela idazten da: erel = e |x| = |x − ¯x| |x| Askotan, |x| balioa ezezagutzen ez dugunez, ohikoa da |¯x| balio ezagunaz zatitzea errore erlatiboa kalkulatzeko, hau da: erel = |x − ¯x| |¯x| . Errore erlatiboa adieraz daiteke portzentaiezko adierazpena erabiliz:  %100 · erel. 1.3 Adibidea. Demagun x = 0.00006 balio zehatza dela eta ¯ x = 0.00005 bere hurbilketa. Egindako errore absolutua txikia dirudi: e = |x − ¯x| = |0.00006 − 0.00005| = 0.00001 = 10 − 5 baina errore erlatiboa handia da: erel = |x − ¯x| |¯x| = 10−5 0.00005 = 0.2 ≡ %20a.  6 1. Kapitulua Errorea eta algoritmoen ezaugarriak 1.4 Adibidea. Demagun x = 100500 balio zehatza dela eta ¯ x = 100000 bere hurbilketa. Orain, errore absolutua handia dirudi: e = |x − ¯x| = 500 baina errore erlatiboa txikia da: erel = |x − ¯x| |¯x| = 500 100000 = 0.005 ≡ %0.5a. 1.3 Koma ﬂotatzaileko adierazpena 1.3.1 Borobiltze-prozesua Ordenagailu batek bakarrik biltegira dezake informazio mugatua. Zenbakiak idazteko, koma ﬂotatzaileko adierazpena erabiliko dugu: x = ±(0.d1d2 . . . dt) · β e, non honako osagai hauek ditugu: • e ∈ Z berretzailea da; • β ∈ N − {1} oinarria da; • di ∈ {0, 1, . . . , β − 1} dijituak dira; • 0.d1d2 . . . dt ∈  [0, 1) zenbakiari mantisa deritzo, zeinen dijituak β oinarrian adierazita dauden, hau da, 0.d1d2 . . . dn ≡ d1 · β − 1 + d2 · β−2 + · · · + dt · β−t. • t ∈ N mantisaren luzera da, eta dijitu esanguratsu kopurua da. 1.3 Deﬁnizioa. Ordenagailuak erabiltzen dituen zenbakiak makina-zenbakiak direla esango dugu, eta honako adierazpen hau erabiliko da: x benetazko zenbakiari f l (x) makina-zenbakia dagokio. Hasiera batean, zenbaki batek koma ﬂotatzaileko adierazpen bat baino gehiago onar- tu dezake: 0.003 = 0.3 · 10 − 2 = 0.03 · 10−1 = 0.00003 · 101 = . . . Hori ekiditzeko, inposatuko diogu mantisari d1 = 0 izatea. Baldintza hori betetzen duten zenbakiei normalizatuta esango zaie.  1.3. Koma ﬂotatzaileko adierazpena 7 Mantisaren luzeraren arabera, esango dugu ordenagailu batek zehaztasun sinple (7 dijitu esanguratsu, hau da, t = 7) edo zehaztasun bikoitza  (16 dijitu esanguratsu, hau da, t = 16) erabiltzen duela. Sinpliﬁkatzeko, beti hartuko dugu β = 10 (oinarri hamartarra, hau da, di ∈ {0, 1, . . . , 9}) baita mantisa normalizatuak ere  (d1 = 0). Honako notazio hauek erabiltzen dira: 2432.91 = 0.243291 · 10 4 = 0.243291E4. Mantisaren luzera (t) txikiegia gertatzen denean, 2 aukera ditugu adierazteko: • mozketa hutsa (hartu mantisa teorikoaren lehenengo t hamartar); • ohiko borobilketa, hau da, dt+1 ≥ 5 bada, orduan, 10− t gehitzen zaio mantisari. 1.5 Adibidea. x = 2/3 = 0.66666 . . . zenbakia adieraziko dugu t = 4 dijitu esan- guratsuz goiko bi teknikak aplikatuz: mozketa hutsa eginez, f l (x) = 0.6666 lortuko genuke, eta borobilduz, aldiz, f l (x) = 0.6667. Mozketaz, 0.00006666 . . . errorea egin dugu, eta borobilduz, aldiz, 0.00003333 . . . . Demagun dt+1 ≤ 4 dela. Orduan, fl(x) berdina lortzen da moztuz zein boro- bilduz. Aldiz, dt+1 ≥ 5 bada, orduan mozketaz egindako errorea, borobilduz egiten dena baino handiagoa da (aurreko adibidean gertatzen denez). Horregatik, beti erabiliko dugu ohiko borobilketa. 1.1 Adibideak. • Borobiltzen badugu π = 3.14159265 . . . zenbakia t = 4 dijitu esanguratsutara, orduan f l(π) = 3.142 da. t = 5 erabiliz, aldiz, f l (π) = 3.1416. • x = 10.18999 bada eta t = 6 erabiltzen badugu, orduan, fl(x) = 10.19. • Borobiltzen badugu x = √ 2 = 1.41421 . . . 4 zifra esanguratsutara, 1.414 lortuko dugu. Borobiltzen badugu 4 zifra dezimaletara, orduan 1.4142 lortuko dugu. 1.3.2 Ordenagailuaren zehaztasuna Bedi x ∈ R. Erabiliko dugu t zifra esanguratsu x adierazteko, eta fl(x) makina- zenbakia kontsideratuz egiten den errorea neurtuko dugu. Badaukagu f l(x) = α · 10 e,  8 1. Kapitulua Errorea eta algoritmoen ezaugarriak non α mantisa normalizatua baita. Badaukagu, ere, x = a · 10 e. Borobiltze prozesuagatik, erraz ikus daiteke |a − α| ≤ 0. t 0 . . . 0 5 = 5 · 10− t− 1 dela. Orduan, borobilduz egiten dugun errore absolutua borna dezakegu honela: e = |x − fl(x)| = |a · 10 e − α · 10e| = 10e · |a − α| ≤ 5 · 10e−t− 1 Adierazpen normalizatua erabiltzeagatik, badaukagu |a| ≥ 0.1. Hori erabiliz, borna dezakegu errore erlatiboa: erel = |x − fl(x)| |x| ≤ 5 · 10 e−t− 1 |a · 10e| ≤ 5 · 10 e−t− 1 10−1 · 10e = 5 · 10 − t Azken borne honi deituko diogu ordenagailuaren zehaztasuna, eta eps = 5 · 10− t adierazpenaz idatziko dugu. 1.1 Lema. x ∈ R guztietarako existitzen da εx ∈ R zeinerako f l(x) = x · (1 + εx) dugun, |εx| ≤ eps izanik. Frogapena. Hartu εx = x−f l (x) x . ♣ Normalean, ordenagailu batean e berretzailearen balio posibleak mugatuta daude. Adibidez, −99 ≤ e ≤ 99 izan daiteke. Kasu horretan, x = 0.3421234E110 ez litza- teke makina- zenbakirik izango, eta overﬂow gertatzen dela esango genuke. Bestalde, y = 0.234321E–110 zenbakiari dagokion makina-zenbakia f l (y) = 0 izango litzateke, eta underﬂow gertatzen dela esango genuke. 1.4 Koma ﬂotatzaileko aritmetika Demagun makina batek t zifra esanguratsuz lanegiten duela. Eragiketa bakoitza egin ondoren, borobilketa egiten du, eta honek ondorio garrantzitsuak dakartza azken emaitzerako.  1.4. Koma ﬂotatzaileko aritmetika 9 1.4.1 Batuketa ez da elkarkorra Ohiko aritmetikan, batuketa elkarkorra da, hau da, a+(b+c) =  (a+b)+c, ∀a, b, c ∈ R. Baina koma ﬂotatzaileko aritmetika erabiltzen dugunean, ordena inportantea da, eta beraz, f l(f l(a + b) + c) = f l(a + f l(b + c)) izan daiteke. 1.6 Adibidea. Kontsidera dezagun t = 4 eta honako zenbaki hauek: a = 0.002333, b = 55.55, c = −55.45 Badaukagu f l(b + c) = 0.1 + 3 f l(a + f l(b + c)) = f l(0.102333) = 0.1023 Bestalde, f l(a+b) = f l(55.5523333) = 55.55 = b + 3 f l(f l(a+b)+c) = f l(b+c) = 0.1 = 0.1023 1.4.2 Elementu neutroa ez da bakarra Aritmetika arrunta erabiliz, x + y = x + 3 y = 0 ondorioztatzen da, baina koma ﬂotatzaileko adierazpenaz, baliteke inﬁnitu y existitzea zeintzuetarako f l (x + y) = x baita. 1.7 Adibidea. t = 3 hartuz, x = 0.234E7, y = 0.123E–2 = 0 eta badaukagu f l(x + y) = f l(2340000.00123) = 0.234E7 = x. Ondorioz, eragiketak gauzatzeko, garrantzi haundia izango du ordenak errorea hedatu ez dadin. Batugaiak ordenatzeko estrategia bereziak ikusiko digutu: 1.1 Trikimailua. Urrezko legetzat har dezakegu honako baieztapen informal hau: “Koma ﬂotatzaileko aritmetikan, inoiz ere ez gehitu zenbaki handi bat txikiegia den beste bati”. Aurreko adibideetan ikusi dugunez, zifra esanguratsu galtzen dira prozesu horretan. 1.2 Trikimailua. Zenbaki batzu batu behar baditugu, hobe dugu txikienetatik hasi, honako adibide honetan frogatuko dugunez: Izan bitez a1, a2, a3, a4, a5 ∈ R eta demagun koma ﬂotatzaileko aritmetika erabiliz batzen ditugula honako ordena hau jarraituz: ((((a1 + a2) + a3) + a4) + a5)  10 1. Kapitulua Errorea eta algoritmoen ezaugarriak Orduan, koma ﬂotatzaileko adierazpena erabiliz, benetazko emaitza honako hau izango litzateke: emaitza = f l (f l (f l (f l(a1 + a2) + a3) + a4) + a5) = ((((a1 + a2)(1 + ε1) + a3) (1 + ε2) + a4) (1 + ε3) + a5) (1 + ε4) Sinpliﬁkatzeko, suposatuko dugu ε1 = ε2 = ε3 = ε4 = ε direla, non |ε| ≤ eps. Biderketak burutuz, badaukagu: emaitza ≃ a1(1 + ε) 4 + a2(1 + ε)4 + a3(1 + ε)3 + a4(1 + ε)2 + a5(1 + ε) = (a1 + a2 + a3 + a4 + a5) + ε(4a1 + 4a2 + 3a3 + 2a4 + a5)+ O (ε2) ε2(. . . ) + . . ., non Landau O larria notazioa erabili dugun  (hondarra zerora ε2 bezain agudo doala adierazteko). Hondar hori mezprezugarritzat eman dezakegu. Laburbilduz, frogatu dugu emaitza ≃ (a1 + a2 + a3 + a4 + a5)ε(4a1 + 4a2 + 3a3 + 2a4 + a5) + 3 errorea = ε(4a1 + 4a2 + 3a3 + 2a4 + a5). Era berean froga daiteke n batugai erabiltzen dugunean, orduan emaitza ≃ (a1 + · · · + an)ε((n − 1)a1 + (n − 1)a2 +  (n − 2)a3 + · · · + 2an−1 + an) + 3 errorea = ε((n − 1)a1 + (n − 1)a2 + (n − 2)a3 + · · · + 2an−1 + an). Nabaria denez, lehenengo bi gaiek eragindako errorea hirugarrenak egindakoa baino handiagoa dela, eta eragin horrek gero eta baxuagoa da. Horregatik hobe dugu batugaiak ordena gorakorrez antolatu batu baino lehen. 1.8 Adibidea. 500 n =1 1 n5 batzeko ordenarik egokiena honako hau da: 1 5005 + 1 4995 + 1 4985 + . . . 1.4.3 Deuseztapen efektua Demagun x eta y oso antzekoak direla eta x−y kalkulatu nahi dugula koma ﬂotatza- ileko aritmetikaz. Orduan, dijitu esanguratsu asko gal ditzakegu, errore erlatibo haundia gertatuz, honako adibide honetan ikus dezakegunez:  1.4. Koma ﬂotatzaileko aritmetika 11 1.9 Adibidea. Bitez x = 0.123444444 eta y = 0.123411111. Orduan, badaukagu x − y = 0.33333E–4. Bestalde, t = 5 dijitu esanguratsuz lanegiten duen makina batek ez luke lortuko x − y balio zehatza, baizik eta: α = f l(f l(x) − fl(y)) = fl(0.12344 − 0.12341) = fl(0.00003) = 0.3000E–4 Nabaritu α- ren mantisako lehen dijitua bakarrik dela zehatza. Beraz, x − y kalku- latzean egindako errore erlatiboa x borobiltzean egindakoa baino askoz handiagoa da. erelx = |fl(x) − x| |x| = 0.000036 ≡ %0.0036, erel(x−y) = |α − (x − y)| |x − y| = 0.09999 · · · ≈ %10 Orain ikusiko dugu deuseztapen efektua ekiditzeko hainbat teknika: 1.3 Trikimailua. Batzuetan, konjokatu egokiaz biderkatzea eta zatitzea komeni- garri gertatzen da, honako adibide honetan ikus dezakegunez: Demagun balioztatu nahi dugula f (x) = 1 − cos x funtzioa , 0-ren hurbileko x batean. Orduan, x ∼ 0 + 3 cos x ∼ 1, eta deuseztapen efektuaren arriskuan egongo gara. Hori ekiditzeko, erabil dezakegu beste adierazpen baliokide bat, zein deuseztapen efektuaren arriskupean ez baitago: 1 − cos x = (1 − cos x) · 1 + cos x 1 + cos x = 1 − cos 2 x 1 + cos x = sin2 x 1 + cos x Adibidez, t = 5 hartzen badugu, eta x = 0.14500E–1 kontsideratuz, badaukagu cos x = 0.99989E0 + 3 1 − cos x = 0.11000E–3, bakarrik lehen dijitua zehatza izanik. Bestalde, 1 + cos x = 0.19999E1, sinx = 0.14499E–1 + 3 sin2 x = 0.21022E–3 + 3 sin2 x 1 + cos x = f l 0.00021022 1.9999 = 0.10512E–3, zeinen hamartar guztiak zehatzak baitira, Taylor seriez konproba dezakegunez: f (x) = 1 − cos x = x2 2 − x4 4! + x6 6! − . . .  12 1. Kapitulua Errorea eta algoritmoen ezaugarriak 1.4 Trikimailua. Demagun 2. mailako ekuazioa ebatzi nahi dugula: ax2 + bx + c = a(x − x1)(x − x2) = 0 + 3 x1,2 = −b ± √ b2 − 4ac 2a . (1.1) Demagun b2 >> 4|ac| dela. Orduan, badaukagu √ b2 − 4ac ≈ |b|, eta erro bat kalku- latzeko formula deuseztapen efektuaren arriskuan egon daiteke. Hori ekiditzeko, badaukagu 2 estrategia. Sinpliﬁkatzeko, suposatuko dugu b > 0 dela. i) x1 = −b + √ b2 − 4ac 2a = −b + √ b2 − 4ac 2a · −b − √ b2 − 4ac −b − √ b2 − 4ac = b2 − b 2 + 4ac 2a(−b − √ b2 − 4ac) = −2c b + √ b2 − 4ac , eta azken adierazpen horrek ez dauka deuseztapen efekturik, ezta x2 kalku- latzeko ohiko formulak ere. ii) Beste estrategia bat izan daiteke honako hau: kalkula dezakegu x2 (ez dago deuseztapen efekturik): x2 = −b − √ b2 − 4ac 2a . Gero, (1.1) formulatik, badaukagu x1 · x2 = c a + 3 x1 = c x2 · a . Nabaritu x1 = −x2 − b/a formula desegokia dela deuseztapen efektuagatik. 1.5 Algoritmoen propietateak Algoritmo bat zehazki deﬁnituriko prozedura ﬁnitu bat da, normalean etapatan antolatuta dago eta erraz idazten da adierazpen formala erabiliz. Horregatik, oso aproposak dira makina batekin programatzeko. 1.5.1 Konbergentzia Algoritmo askotan, {un}n∈N segida bat sortzen da, un gaia algoritmoko n-garren pausuan lortzen den emaitza izanik. Baldintza batzuk betetzen badira, segida ho- rrek problemaren soluzio zehatzera konbergitzen du. Konbergentziaren abiadura oso garrantzitsua izango da, ere.  1.5. Algoritmoen propietateak 13 1.5.2 Egonkortasuna eta problemaren baldintzatzea Nahiz eta algoritmo bat konbergente eta azkarra izan, horrek ez du ezertarako balio borobiltze-errorea kontrolatuta ez badago. Algoritmo baten zehar borobiltze-erroreak gehiegi hedatzen badira, irteerako emaitzak nahiko okerrak izan daitezke. Kasu horretan, esaten da algoritmoa de- segonkorra dela. Bestela, borobiltze-errorea kontrolatzen bada, esango dugu algo- ritmoa egonkorra dela. Bestalde, baliteke algoritmo bat oso “sentibera” izatea honako sentzu hone- tan: hasierako baldintzetako aldaketa txikiek eragin handia badaukate bukaerako emaitzetan, esango dugu algoritmoa edo problema txarto baldintzatuta dagoela. 1.10 Adibidea. 2x +6y =8 2x +6.00001y =8.00001 sistemaren ebazpen zehatza x = 1 y = 1 da. 2x +6y =8 2x +5.99999y =8.00002 sistemaren ebazpen zehatza x = 10 y = −2 da. Hastapen baldintzen bariazioa 10−5 ordenakoa izan da, baina emaitzaren bariazioa, aldiz, 101 ordenakoa. Sistema hori txarto baldintzatuta dago. 1.11 Adibidea (Wilkinson, 1959). p(x) = 20 i =1 (x − i) = (x − 1) · (x − 2) . . . (x − 20) = x20 − 210x 19 + 2065x18 − · · · + 20! = a0x 20 + a1x19 + · · · + a20. polinomioaren erroak 1, 2, . . . , 20 dira. Sortuko dugu q (x) polinomio berri bat p(x)- ren koeﬁziente bat pixkat aldatuz honela: q(x) = a0x 20 − (210 + 10−7)x19 + a2x18 + · · · + a20. Polinomio berri horren erroak honako hauek dira: 1, 2, 3, 4, 4.999999939, 6.000005825, 6.999745979, . . . . . . , 16.72503985 ± 2.731576697i, 19.45963983 ± 1.87435706i, 20.788880562. Esate baterako, polinomio baten erroak kalkulatzea bere koeﬁzienteekiko txarto baldintzatua dago. Ondorioz, zenbakizko ikuspuntutik matrize baten autobalioak polinomio karakteristikoaren bidez kalkulatzeko metodoa txarto baldintzatua da- go, eta beraz, beste metodoak erabiliko ditugu.  14 1. Kapitulua Errorea eta algoritmoen ezaugarriak 1.5.3 Eragiketa-kostua Komenigarria da ahalik eta eragiketa gutxien egitea, ekonomia, denbora eta zehaz- tasunagatik. Algoritmo bakoitzean aztertuko dugu, ba, eragiketa-kostua. Orokor- rean, eragiketa kostuak kalkulatzeko, batuketak ez dira kontuan hartzen, biderketa batekin konparatuz batuketa bat egiteko denbora mesprezugarritzat hartzen baita. H¨ orner algoritmoa Metodo bikaina da polinomio bat eta bere deribatuak puntu jakin batean balioz- tatzeko, eragiketa kostua ikuspuntutik. Honako berridazketa honetan dago oinar- rituta: p(x) = a0x n + a1xn−1 + · · · + an − 1x + an = ((. . . ((a0x + a1)x + a2)x + . . . )x + an−1)x + an Ohiko adierazpenaz, p(x) ebaluatzeko, n + (n − 1) + · · · + 2 + 1 ≃ n 2/2 biderketa eta n batuketa egin behar dira. Bestalde, bigarren adierazpenaz, bakarrik n biderketa eta n batuketa dira beharrezkoak. H¨orner algoritmoaren deskribapena zera da: Demagun p(x) polinomioa r puntuan ebaluatu nahi dugula. Orduan, a0, . . . , an koeﬁzienteekin honako segida hau sor daiteke: b0 = a0 b1 = b0 · r + a1 b2 = b0 · r + a2 . . . bk = bk − 1 · r + ak . . . bn = bn − 1 · r + an Ondorioz, p(r) = bn. Algoritmoa deskriba daiteke honako era trinko honetan: b0 = a0 bi = bi − 1 · r + ai, i = 1, 2, . . . , n. Sorturiko b0, . . . , bn−1 koeﬁzienteak erabiliko ditugu p′ (r) kalkulatzeko. Horretarako, honako eragiketa aljebraiko honetaz baliatuko gara: p (x) polinomioa x−r polinomi- otik zatituz, qn − 1(x) zatidura eta R0 ∈ R hondarra lortzen dira, hau da p(x) = (x − r) · qn−1(x) + R0.  1.5. Algoritmoen propietateak 15 1.2 Lema. Aurreko baldintzetan, R0 = bn eta qn − 1(x) = b0x n− 1 + b1xn−2 + · · · + bn − 1 (1.2) Frogapena. (x − r) · (b0x n− 1 + b1xn−2 + · · · + bn − 1) + bn = b0x n + (b1 − r · b0)xn− 1 + (b2 − r · b1)xn−2 + · · · + (bn − 1 − r · bn−2)x + (bn − r · bn−1) = a0x n + a1xn−1 + · · · + an − 1x + an = p(x) ♣ Orain, (1.2) deribatuz, p ′(x) = (x − r) · q′n − 1(x) + qn−1(x) + 3 p ′(r) = qn − 1(r), eta erabiliko dugu H¨orner metodoa qn − 1(r) kalkulatzeko: c0 = b0 c1 = c0 · r + b1 c2 = c0 · r + b2 . . . ck = ck − 1 · r + bk . . . cn − 1 = cn−2 · r + bn−1 = qn−1(r) = p ′(r) Are gehiago, p′′ (r) kalkulatzeko, aurreko lema eta emaitzak erabil ditzakegu. Hasteko, zatitu dezakegu qn − 1(x) polinomioa (x − r)-tik, honako hau lortuz: qn − 1(x) = (x − r) · qn−2(x) + R1, (1.3) non R1 ∈ R eta qn−2(x) = c0x n− 2 + c1xn−3 + · · · cn − 3x + cn−2. Orduan, (1.2) eta (1.3) erabiliz, p(x) = (x − r) 2q n− 2(x) + R1(x − r) + R0 p ′ (x) = 2(x − r)qn−2(x) + (x − r) 2q′ n− 2(x) + R1 p ′′ (x) = 2qn − 2(x) + 4(x − r)q ′ n− 2(x) + (x − r) 2q′′ n− 2(x) + 3 p ′′(r) = 2 · qn−2(r). Jakina, qn − 2(r) kalkulatzeko, H¨ orner algoritmoa erabiliko genuke, ci koeﬁzienteak erabiliz. Orokorrean, goiko ordenako deribatuak ebaluatzeko, prozesua k aldiz erre- pikatuz, badaukagu p k )(r) = k!q n−k(r) Komenigarria da kalkuluak antolatzea Ruﬃni ebaluaketa moduan. ADIBIDEA  16 1. Kapitulua Errorea eta algoritmoen ezaugarriak 1.5.4 Memoriaren erabilera Komenigarria da ahalik eta memoria gutxien erabiltzea algoritmo bat burutzeko. Egoera optimoan, INPUT gordetzeko memoria espazioa besterik ez da erabiltzen OUTPUT lortu eta biltegiratzeko. Horretarako, urrezko lege orokor bat dago: prozesu baten zehar, datu bat beharrezkoa baldin ez bada, orduan ezaba deza- kegu eta hutsik uzten duen lekua aprobetxa dezakegu behar izango dugun beste datu bat biltegiratzeko. Adibidez, ikusiriko H¨orner algoritmoaz kalkula eta biltegira daitezke p(r), p′(r), . . . , pn) (r) balioak a0, . . . , an koeﬁzienteak biltegiratzeko behar dugun n + 1 luzerako bektore bat erabiliz. (ADIBIDEA) 1.5.5 Metodo motak • Metodo zuzenak • Teoriaz, ebazpen zehatza lortzen da. • Borobilduz errorea heda daiteke. • Iteraziozko meodoak • Hurbilpenak lortzen dira etapa bakoitzean {un}n∈N −→ u • borobiltze-errorea ez da hain inportante. Konbergentzia nahitaezkoa da.
