<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by OpenOffice.org - see http://xml.openoffice.org/odf2xhtml for more info.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.creator" content="IKERM "/><meta name="DCTERMS.issued" content="2017-02-15T12:54:20" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.contributor" content="IKERM "/><meta name="DCTERMS.modified" content="2017-02-15T13:41:39" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/></head><body dir="ltr" ><p class="Standard">5&#13;</p><p class="Standard">Programa errekurtsiboen transformazioa:&#13;</p><p class="Standard">Burstall-en metodoa&#13;</p><p class="Standard">5.1 Burstall-en metodoa, programa errekurtsiboak&#13;</p><p class="Standard">iteratibo bihurtzeko&#13;</p><p class="Standard">Programa errekurtsiboak soluziorik zuzenena, sinpleena eta argiena izaten dira zenbait&#13;</p><p class="Standard">problematarako. Esate baterako:&#13;</p><p class="Standard">• Indukzio bidez definitutako funtzioak.&#13;</p><p class="Standard">• Datu-mota induktiboen tratamendua.&#13;</p><p class="Standard">• Izaera bereko azpiproblematan banatzen diren problemak.&#13;</p><p class="Standard">Baina askotan, batez ere programa iteratiboekin konparatuz, ez dira eraginkorre-&#13;</p><p class="Standard">nak. Eraginkor ez izate hori bi arrazoi hauengatik gertatzen da:&#13;</p><p class="Standard">• Kalkuluen errepikapenagatik.&#13;</p><p class="Standard">• Parametroak gorde eta berreskuratu behar direlako deiak kateatzean.&#13;</p><p class="Standard">Hala ere, esan dugunez, zenbaitetan errazagoa da algoritmo errekurtsiboa gara-&#13;</p><p class="Standard">tzea iteratiboa garatzea baino. Horregatik, oso interesgarria da ebazpide errekurtsiboa&#13;</p><p class="Standard">abiapuntu gisa erabiltzea programa iteratibo bat lortzeko, bereziki batetik besterako&#13;</p><p class="Standard">bihurketa era metodikoan egiten bada. Horrela jokatuz gero, ebazpide eraginkorragoa&#13;</p><p class="Standard">lor daiteke eta, era berean, azkeneko programa iteratiboaren zuzentasuna justifikatuta&#13;</p><p class="Standard">geratzen da.&#13;</p><p class="Standard">Gainera, transformazio-eredu honen bidez sakonki azter daiteke errekurtsibitatearen&#13;</p><p class="Standard">eta iterazioaren arteko erlazioa.&#13;</p><p class="Standard">Gai honetan, Burstall-en metodoa1 landuko dugu. Metodo honek funtzio errekur-&#13;</p><p class="Standard">tsiboak iteratibo bihurtzeko balio du.&#13;</p><p class="Standard">Honako hauek dira metodoaren oinarriak:&#13;</p><p class="Standard">1. Abiapuntutzat, algoritmo errekurtsiboa edo zehaztapen induktiboa hartzen da.&#13;</p><p class="Standard">2. Formulazio induktibo horri erreparatuta, soluzioaren errekurrentzia-erlazioa ate-&#13;</p><p class="Standard">ratzen da.&#13;</p><p class="Standard">1 A Transformation System for Developing Recursive Programs. R.M Burstall and J. Darlington.&#13;</p><p class="Standard">In Journal of the ACM, Volume 24, Issue 1, pages 44-67. January 1977.&#13;</p><p class="Standard">1&#13;</p><p class="Standard">3. Errekurrentzia-erlazio hori izango da, hain zuzen ere, oraindik sortu gabe da-&#13;</p><p class="Standard">goen iterazioaren inbariantea. Iterazioaren borne-adierazpena ere pauso honetan&#13;</p><p class="Standard">asmatzen da.&#13;</p><p class="Standard">4. Inbariante hori oinarri hartuta, iterazioa edo algoritmo iteratiboa formalki era-&#13;</p><p class="Standard">tortzen da, honako urratsetan: hasieraketa, bukaerako tratamendua (emaitza) eta&#13;</p><p class="Standard">iterazioaren gorputza.&#13;</p><p class="Standard">Iterazioaren gorputza eratortzeko, definizio induktiboan eta inbariantean oinarrituta,&#13;</p><p class="Standard">destolesketa/tolesketa teknika erabiltzen da.&#13;</p><p class="Standard">5.2 Metodoaren deskribapena&#13;</p><p class="Standard">Esan bezala, Burstall-en metodo orokorra funtzio baten definizio induktiboarekin has-&#13;</p><p class="Standard">ten da&#13;</p><p class="Standard">f : T1 × . . . × Tn → T&#13;</p><p class="Standard">non T = T1 . . . Tn diren funtzioko parametro formalen motak, eta T den emaitzaren&#13;</p><p class="Standard">mota. x = x1 . . . xn deituko diegu parametro formalei (x1 ∈ T1 , . . . , xn ∈ Tn ). De-&#13;</p><p class="Standard">finizio induktibo horretatik errekurrentzia-erlazio bat ateratzen da, eta erlazio hori&#13;</p><p class="Standard">inbariantetzat hartzen da. Honako hau izango da inbariantearen forma:&#13;</p><p class="Standard">IN B ≡ f (x) = F (f (y), z)&#13;</p><p class="Standard">non y eta z aldagai berriak diren, iterazioan erabiliko direnak. F funtzioaren bidez&#13;</p><p class="Standard">adierazten dugu f (y) eta z-ren arteko erlazioa, hasierako funtzioaren definizio indukti-&#13;</p><p class="Standard">botik asmatu behar duguna. Orokorrean, errekurrentzia erlazioak antz handia hartzen&#13;</p><p class="Standard">du kasu induktiboek bueltatzen duten emaitzarekin.&#13;</p><p class="Standard">Borne-adierazpena y aldagaien gainean definituko da, eta iterazioak bukatzeko falta&#13;</p><p class="Standard">dituen pausoen kopurua mugatuko du.&#13;</p><p class="Standard">Inbariante horretatik eratorriko den funtzio iteratiboak honako forma hartzen du:&#13;</p><p class="Standard">function f_it(x : T) return T’ is&#13;</p><p class="Standard">y : T;&#13;</p><p class="Standard">z : ?;&#13;</p><p class="Standard">begin&#13;</p><p class="Standard">- - Hasieraketa&#13;</p><p class="Standard">while not bukbal(y) loop&#13;</p><p class="Standard">INB ≡ { f (x) = F (f (y), z) }&#13;</p><p class="Standard">- - Gorputza&#13;</p><p class="Standard">E ≡ g(y)&#13;</p><p class="Standard">(y,z) := (y’,z’);&#13;</p><p class="Standard">end loop;&#13;</p><p class="Standard">- - Emaitza&#13;</p><p class="Standard">end f_it;&#13;</p><p class="Standard">f _it funtzio iteratiboaren goi-burukoa f funtzio errekurtsiboaren berdina da: pa-&#13;</p><p class="Standard">rametro berdinak hartzen ditu (x) eta emaitza ere mota berekoa da. Hori bai, f _it&#13;</p><p class="Standard">funtzioak beste aldagai laguntzaile batzuk ere erabiltzen ditu: y eta z. x parametroek&#13;</p><p class="Standard">konputazio errekurtsiboan hartuko lituzketen balioak gordetzeko erabiltzen dira y alda-&#13;</p><p class="Standard">gaiak algoritmo iteratiboan, eta horregatik dira mota berekoak. z aldagaiak informazio&#13;</p><p class="Standard">osagarria gordetzeko erabiltzen dira.&#13;</p><p class="Standard">Programaren lehenengo zatia hasieraketa da, eta bertan y eta z aldagaiak hasieratu&#13;</p><p class="Standard">behar dira inbariantea iteraziora sartzerako bete dadin.&#13;</p><p class="Standard">2&#13;</p><p class="Standard">Programaren bigarren zatia iterazioa bera da, non bukaera-baldintza (bukbal fun-&#13;</p><p class="Standard">tzioa) eta gorputza definitu behar diren. Bukaera-baldintza definitzeko, hasierako al-&#13;</p><p class="Standard">goritmo errekurtsiboko kasu nabariekin parekatzen dira iterazioko bukaera-kasuak.&#13;</p><p class="Standard">Oinarria sinplea da: iterazioa bukatuko da errekurtsioa bukatuko litzatekeen egoera&#13;</p><p class="Standard">berdinetan. Hori bai, kontuan hartu behar da errekurtsioaren bukaera x parametroen&#13;</p><p class="Standard">arabera formulatzen zela, eta iterazioan, berriz, y aldagaien arabera formulatu behar-&#13;</p><p class="Standard">ko da. Hortaz, bukbal funtzioa kasu nabari guztien baldintzen disjuntzioa izango da.&#13;</p><p class="Standard">Iterazioaren gorputzari dagokionez, irizpide nagusia honako hau da: iterazioko pauso&#13;</p><p class="Standard">bakoitzak dei errekurtsibo bat simulatu behar du. Nolabait, algoritmo errekurtsiboaren&#13;</p><p class="Standard">exekuzioan dei batetik bestera gertatzen ziren aldaketak izango dira y eta z aldagaie-&#13;</p><p class="Standard">tan jasoko direnak. Aldagai horiei, beraz, balio berriak esleitzen zaizkie iterazio-pauso&#13;</p><p class="Standard">bakoitzean. Metodoaren aplikazioan, balio berri horiek zaharretatik bereizteko horrela&#13;</p><p class="Standard">izendatuko dira: y eta z . Balio horiek destolesketa/tolesketa teknikaren bidez lortzen&#13;</p><p class="Standard">dira inbariantea oinarritzat hartuta eta kasu induktiboen arabera. Behin balio berriak&#13;</p><p class="Standard">zein izango diren erabakita, erraz asma daiteke gorputzaren kodea: azken batean, y&#13;</p><p class="Standard">eta z aldagaiei balio berriak esleitu beharko zaizkie. Asignazio horiek, formalki, aldi&#13;</p><p class="Standard">berean gertatzen dira eta (y, z) := (y , z ) notazioarekin adieraz daiteke aldi berekoak&#13;</p><p class="Standard">direla. Baina, ADAn asignazioak banan-banan egin beharra dagoenez, kontu handia&#13;</p><p class="Standard">eduki behar da asignazioen hurrenkerarekin, eta batzuetan aldagai laguntzaileak ere&#13;</p><p class="Standard">erabili behar dira. Gainera, kasu induktibo bat baino gehiago dagoenean, kasu ho-&#13;</p><p class="Standard">rien araberako esleipen baldintzatuak egin behar izaten dira, eta horregatik, if agindua&#13;</p><p class="Standard">erabiltzen da.&#13;</p><p class="Standard">Programaren azken zatian bukaerako tratamendua egiten da, hau da, azken emaitza&#13;</p><p class="Standard">lortzea. Emaitza zein den kalkulatzeko inbariantearen ebaluazioa egiten da y eta z&#13;</p><p class="Standard">aldagaien balioekin (iteraziotik ateratakoan izango dituzten balioekin). Honakoan ere,&#13;</p><p class="Standard">kasu nabari bat baino gehiago badago, kasu horiek denak ondo tratatzeko if agindu&#13;</p><p class="Standard">bat erabiltzen da.&#13;</p><p class="Standard">5.3 Metodoaren aplikazio-adibideak&#13;</p><p class="Standard">Lehenengo adibidea zenbakien oinarri-aldaketa da. Izan bedi oinald(x, b) funtzioa, x&#13;</p><p class="Standard">zenbaki arruntaren b oinarriko errepresentazioa itzultzen duena:&#13;</p><p class="Standard">oinald: Integer × Integer → sekuentzia(Integer)&#13;</p><p class="Standard">Aurre: 1 &lt; b &lt; 10 ∧ x ≥ 0&#13;</p><p class="Standard">x&#13;</p><p class="Standard">baldin x &lt; b&#13;</p><p class="Standard">oinald(x, b) =&#13;</p><p class="Standard">oinald(x/b, b)@ x mod b bestela&#13;</p><p class="Standard">Definizio errekurtsibo hori programa iteratibo bihurtuko dugu.&#13;</p><p class="Standard">1. Hasteko, errekurrentzia-erlazioa atera behar dugu. Helburu horretara iristeko&#13;</p><p class="Standard">hurbilpen egokia da destolesketa/tolesketa teknika erabiltzea adibide zehatz ba-&#13;</p><p class="Standard">ten gainean. Adibidez, oinald(123, 4) adibidea hartuko dugu, eta espresio horren&#13;</p><p class="Standard">kalkulua egingo dugu definizio induktiboak adierazitakoaren arabera. Kalkulu&#13;</p><p class="Standard">horretan, destolesketa-urrats bakoitzean funtzioaren definizioa aplikatzen da eta,&#13;</p><p class="Standard">berriz, tolesketa-urrats bakoitzen, lortzen dugun adierazpena sinplifikatu egiten&#13;</p><p class="Standard">da.&#13;</p><p class="Standard">oinald(123, 4) destolestuta oinald(30, 4)@ 3 lortzen dugu (oinald-en kasu in-&#13;</p><p class="Standard">duktiboa), eta adierazpen hau ezin da sinplifikatu. Ondoren, beste destolesketa-&#13;</p><p class="Standard">urrats bat egingo dugu, orain oinald(30, 4)-ren gainean, eta oinald(7, 4)@ 2 ate-&#13;</p><p class="Standard">ratzen da (kasu induktiboa). Adierazpen osoa (oinald(7, 4)@ 2 )@ 3 da eta,&#13;</p><p class="Standard">3&#13;</p><p class="Standard">sekuentzien kateaketa elkarkorra denez, sinplifika daiteke (tolesketa-urratsa):&#13;</p><p class="Standard">oinald(7, 4)@ 2, 3 . Berriro beste destolesketa-urrats bat egingo da oinald(7, 4)-&#13;</p><p class="Standard">ren gainean, eta, horrela, bukatu arte. Laburbilduz, destolesketa/tolesketa tek-&#13;</p><p class="Standard">nika erabiliz gelditzen den transformazioa horrelakoa da:&#13;</p><p class="Standard">oinald(123, 4)&#13;</p><p class="Standard">destolestu/tolestu&#13;</p><p class="Standard">= oinald(30, 4) @ 3&#13;</p><p class="Standard">destolestu&#13;</p><p class="Standard">= (oinald(7, 4)@ 2 )@ 3&#13;</p><p class="Standard">tolestu&#13;</p><p class="Standard">= oinald(7, 4) @ 2, 3&#13;</p><p class="Standard">destolestu&#13;</p><p class="Standard">= (oinald(1, 4)@ 3 )@ 2, 3&#13;</p><p class="Standard">tolestu&#13;</p><p class="Standard">= oinald(1, 4) @ 3, 2, 3&#13;</p><p class="Standard">destolestu&#13;</p><p class="Standard">= 1 @ 3, 2, 3&#13;</p><p class="Standard">tolestu&#13;</p><p class="Standard">= 1, 3, 2, 3&#13;</p><p class="Standard">Orain, transformazio hori aztertzen da errekurrentzia ateratzeko. Horretarako,&#13;</p><p class="Standard">tolesketa-urrats guztien ondoren gelditzen den adierazpena kontuan hartzen du-&#13;</p><p class="Standard">gu:&#13;</p><p class="Standard">oinald(30, 4)@ 3&#13;</p><p class="Standard">oinald(7, 4)@ 2, 3&#13;</p><p class="Standard">oinald(1, 4)@ 3, 2, 3&#13;</p><p class="Standard">1, 3, 2, 3&#13;</p><p class="Standard">Azkena izan ezik, oso erraz ikus daiteke gelditzen den adierazpenaren forma oro-&#13;</p><p class="Standard">korra horrelakoa dela&#13;</p><p class="Standard">oinald(x, b) = oinald(y, b)@S&#13;</p><p class="Standard">non x, b eta y zenbaki arruntak diren, eta S zenbaki arrunten sekuentzia bat.&#13;</p><p class="Standard">Hau da, hasierako espresioa beti da zenbaki baten oinarri-aldaketaren emaitza&#13;</p><p class="Standard">zenbaki osokoen sekuentzia batekin kateatuta. Adierazpen hori da atera dugun&#13;</p><p class="Standard">errekurrentzia-erlazioa eta hori izango da, hain zuzen, inbariantetzat hartuko du-&#13;</p><p class="Standard">guna. Garbi ikusten da inbariantea eta kasu induktiboaren emaitza oso antzekoak&#13;</p><p class="Standard">direla.&#13;</p><p class="Standard">Borne-adierazpena ere asma dezakegu egin dugun transformazioan oinarrituta.&#13;</p><p class="Standard">Destolesketa/tolesketa prozesuan ikusi dugu y aldagaia gero eta txikiagoa egiten&#13;</p><p class="Standard">dela, harik eta b baino txikiagoa izan eta prozesua bukatu den arte. Borne-&#13;</p><p class="Standard">adierazpena, hortaz, honako hau izan daiteke: E ≡ y&#13;</p><p class="Standard">4&#13;</p><p class="Standard">2. Ondoren, eta inbariantea abiapuntutzat hartuta, programa iteratiboaren atal&#13;</p><p class="Standard">guztiak eratortzen dira:&#13;</p><p class="Standard">• Hasieraketa. Ataza honek ziurtatu behar du inbariantea betetzen dela lehe-&#13;</p><p class="Standard">nengo iterazioa egikaritu baino lehenago. Horretarako, pentsatu behar dugu&#13;</p><p class="Standard">zein balio hartu behar duten y eta S aldagaiek&#13;</p><p class="Standard">oinald(x, b) = oinald(y, b)@S&#13;</p><p class="Standard">inbariantea betetzeko. Kasu honetan, soluziorik errazena honako hau da:&#13;</p><p class="Standard">y := x;&#13;</p><p class="Standard">S := &lt;&gt;;&#13;</p><p class="Standard">• Bukaera-baldintza. Hasierako definizio induktiboan kasu nabari bakar bat&#13;</p><p class="Standard">dago, x &lt; b baldintzaren bidez adierazten dena. Iterazioan, hortaz, bukaera-&#13;</p><p class="Standard">baldintza sinplea izango da, eta horrela formulatuko da: bukbal(y) ≡ y &lt; b.&#13;</p><p class="Standard">• Emaitza. Bukaera-baldintza bakarra dagoenez, emaitza ere modu bakunean&#13;</p><p class="Standard">adieraz dezakegu (if aginduaren beharrik gabe). Inbariantean oinald(y, b)&#13;</p><p class="Standard">adierazpena bere balioarekin ( y ) ordeztuta lortuko dugu emaitza:&#13;</p><p class="Standard">y &lt; b → oinald(x, b) = oinald(y, b)@S = y @S = y • S&#13;</p><p class="Standard">Hau da, emaitza y • S da. ADAn adierazita:&#13;</p><p class="Standard">return y • S;&#13;</p><p class="Standard">• Iterazioaren gorputza. Inbariantea abiapuntu hartuta, destolesketa / toles-&#13;</p><p class="Standard">keta teknika erabiliko dugu kasu induktibo bakarrarekin:&#13;</p><p class="Standard">oinald(x, b)&#13;</p><p class="Standard">= oinald(y, b) @S&#13;</p><p class="Standard">destolestu&#13;</p><p class="Standard">= (oinald(y/b, b)@ y mod b )@S&#13;</p><p class="Standard">tolestu&#13;</p><p class="Standard">= oinald( y/b ,b)@( y mod b @S)&#13;</p><p class="Standard">= oinald( y , b)@&#13;</p><p class="Standard">S&#13;</p><p class="Standard">Hau da, iterazioen gorputza honako aldibereko asignazioa da:&#13;</p><p class="Standard">(S,y) := (&lt; y mod b &gt; @ S,y/b);&#13;</p><p class="Standard">Aldibereko asignazio anizkoitz honen asignazioak ezin daitezke edozein or-&#13;</p><p class="Standard">denatan egin. S sekuentzia eguneratzeko erabiltzen den y aldagaiaren balioa&#13;</p><p class="Standard">zaharra da, y eguneratu aurrekoa. Beraz, beharrezkoa da y eguneratu au-&#13;</p><p class="Standard">rretik S eguneratzea:&#13;</p><p class="Standard">S := &lt; y mod b &gt; @ S;&#13;</p><p class="Standard">y := y/b;&#13;</p><p class="Standard">Horrenbestez, metodoa aplikatuta lortu dugun funtzio iteratiboa honako hau da:&#13;</p><p class="Standard">5&#13;</p><p class="Standard">function oinald_it(x,b : Integer) return sekuentzia(Integer) is&#13;</p><p class="Standard">y : Integer;&#13;</p><p class="Standard">S : sekuentzia(Integer);&#13;</p><p class="Standard">begin&#13;</p><p class="Standard">{ 1 &lt; b &lt; 10 ∧ x ≥ 0 }&#13;</p><p class="Standard">y := x;&#13;</p><p class="Standard">S := &lt;&gt;;&#13;</p><p class="Standard">INB ≡ { oinald(x, b) = oinald(y, b)@S }&#13;</p><p class="Standard">while not y &lt; b loop&#13;</p><p class="Standard">E≡y&#13;</p><p class="Standard">S := &lt; y mod b &gt; @ S;&#13;</p><p class="Standard">y := y/b;&#13;</p><p class="Standard">end loop;&#13;</p><p class="Standard">return y • S;&#13;</p><p class="Standard">end oinald_it;&#13;</p><p class="Standard">{ oinald_it(x, b) = oinald(x, b) }&#13;</p><p class="Standard">Ikusiko dugun bigarren adibidea sekuentzien nahasketa egitean datza. Adibide ho-&#13;</p><p class="Standard">netan deskribatzen da zer gertatzen den kasu induktiboetan erabiltzen diren eragiketak&#13;</p><p class="Standard">ez-elkarkorrak direnean.&#13;</p><p class="Standard">Izan bedi nahastu funtzioa, non nahastu(S, R) adierazpenak S eta R sekuentzien&#13;</p><p class="Standard">fusioa itzultzen duen:&#13;</p><p class="Standard">nahastu: sekuentzia(T ) × sekuentzia(T ) → sekuentzia(T )&#13;</p><p class="Standard">(1) nahastu( , R) = R&#13;</p><p class="Standard">(2) nahastu(S, ) = S&#13;</p><p class="Standard">(3) nahastu(x • S, y • R) =&#13;</p><p class="Standard">x • nahastu(S, y • R) baldin x ≤ y&#13;</p><p class="Standard">y • nahastu(x • S, R) bestela&#13;</p><p class="Standard">Funtzio honek bi kasu nabari eta bi kasu induktibo ditu. Aplika dezagun Burstall-&#13;</p><p class="Standard">en metodoa, definizio induktibo horretatik funtzio iteratibo bat lortzeko.&#13;</p><p class="Standard">1. Aurreko adibidean egin dugun bezalaxe, destolesketa/tolesketa teknika erabiliko&#13;</p><p class="Standard">dugu datu zehatz batzuen gainean errekurrentzia erlazioa ateratzeko. Baina, adi-&#13;</p><p class="Standard">bide honetan, datuak aukeratzean kasu induktibo guztiak gerta daitezen bilatuko&#13;</p><p class="Standard">dugu. Esate baterako, nahastu( 1, 4, 6 , 2, 3 ) adibide on bat da, 1 (lehenengo&#13;</p><p class="Standard">sekuentziako lehenengo osagaia) 2 (bigarren sekuentziako lehenengo osagaia) bai-&#13;</p><p class="Standard">no txikiagoa delako (lehenengo kasu induktiboa), eta 4 (lehenengo sekuentziako&#13;</p><p class="Standard">bigarren osagaia) 2 baino handiagoa delako. Alegia, definizio induktiboaren ara-&#13;</p><p class="Standard">berako kalkuluan, bi kasu induktiboak gertatuko dira, eta horrek orokortasuna&#13;</p><p class="Standard">ematen dio egindako transformazioari.&#13;</p><p class="Standard">Hala bada, nahastu( 1, 4, 6 , 2, 3 ) destolestu ondoren 1 • nahastu( 4, 6 , 2, 3 )&#13;</p><p class="Standard">lortzen dugu (funtzioaren lehenengo kasu induktiboa). Sinplifikatu ezin denez,&#13;</p><p class="Standard">nahastu( 4, 6 , 2, 3 ) destolesten dugu, eta 2 • nahastu( 4, 6 , 3 ) lortzen du-&#13;</p><p class="Standard">gu. Adierazpen osoa 1 • (2 • nahastu( 4, 6 , 3 )) da, eta adierazpen hau ezin&#13;</p><p class="Standard">da sinplifikatu • eragiketa erabiliz. Kontua da • ez-elkarkorra dela eta, horre-&#13;</p><p class="Standard">gatik, ezin ditugula 1, 2 eta nahastu( 4, 6 , 3 )) adierazpenak beste era batean&#13;</p><p class="Standard">•-ren bidez erlazionatu. Kasu hauetan, funtzio ez-elkarkorra beste funtzio bate-&#13;</p><p class="Standard">kin ordezkatzen da, elkarkorra dena. Sekuentziak osatzeko elkarkorra den fun-&#13;</p><p class="Standard">tzio bat kateaketa (@) da eta, horren bidez, aurreko adierazpena toles daiteke:&#13;</p><p class="Standard">1, 2 @nahastu( 4, 6 , 3 ). Hortaz, • funtzioa kateaketarekin (@) ordezkatuta,&#13;</p><p class="Standard">destolesketa/tolesketa prozesu osoa horrela gelditzen da:&#13;</p><p class="Standard">6&#13;</p><p class="Standard">nahastu( 1, 4, 6 , 2, 3 )&#13;</p><p class="Standard">destolestu&#13;</p><p class="Standard">= 1 • nahastu( 4, 6 , 2, 3 )&#13;</p><p class="Standard">tolestu&#13;</p><p class="Standard">= 1 @ nahastu( 4, 6 , 2, 3 )&#13;</p><p class="Standard">destolestu&#13;</p><p class="Standard">= 1 @(2 • nahastu( 4, 6 , 3 ))&#13;</p><p class="Standard">tolestu&#13;</p><p class="Standard">= 1, 2 @ nahastu( 4, 6 , 3 )&#13;</p><p class="Standard">destolestu&#13;</p><p class="Standard">= 1, 2 @(3 • nahastu( 4, 6 ,&#13;</p><p class="Standard">))&#13;</p><p class="Standard">tolestu&#13;</p><p class="Standard">= 1, 2, 3 @ nahastu( 4, 6 ,&#13;</p><p class="Standard">)&#13;</p><p class="Standard">destolestu&#13;</p><p class="Standard">= 1, 2, 3 @ 4, 6&#13;</p><p class="Standard">tolestu&#13;</p><p class="Standard">= 1, 2, 3, 4, 6&#13;</p><p class="Standard">Transformazio hori aztertu ondoren ateratzen den errekurrentzia-erlazioa honako&#13;</p><p class="Standard">hau da&#13;</p><p class="Standard">nahastu(S, R) = U @nahastu(V, W )&#13;</p><p class="Standard">non S, R, U , V eta W zenbaki osokoen sekuentziak diren. U , V eta W aldagai&#13;</p><p class="Standard">berriak dira. Ikus daitekeenez, kasu induktiboetan erabiltzen diren adierazpe-&#13;</p><p class="Standard">netatik atera da errekurrentzia-erlazioa, • funtzioa kateaketarekin ordezkatuz.&#13;</p><p class="Standard">Errekurrentzia-erlazio hori funtzio iteratiboaren inbariantea izango da.&#13;</p><p class="Standard">Borne-adierazpenari dagokionez, esan dezakegu bukaerarako falta dena V eta W&#13;</p><p class="Standard">sekuentzien luzeraren araberakoa dela. Aukera bat baino gehiago badaude ere,&#13;</p><p class="Standard">borne-adierazpen egokia da honako hau: E ≡ luz(V ) + luz(W ), non luz(V ) eta&#13;</p><p class="Standard">luz(W ) V eta W sekuentzien luzerak diren hurrenez hurren.&#13;</p><p class="Standard">2. Ondoren, eta inbariantea ardatz hartuta, programa iteratiboaren zati guztiak&#13;</p><p class="Standard">eratorriko ditugu:&#13;</p><p class="Standard">• Hasieraketa. while-ra lehenengo aldiz iristean inbariantea bete dadin, hona-&#13;</p><p class="Standard">ko asignazio hauek egin daitezke hasieran:&#13;</p><p class="Standard">U := &lt;&gt;;&#13;</p><p class="Standard">V := S;&#13;</p><p class="Standard">W := R;&#13;</p><p class="Standard">• Bukaera-baldintza. Bi kasu nabari daudenez, horiek ondo jasotzen dituen&#13;</p><p class="Standard">bukaera-baldintza disjuntzio baten bidez adieraziko dugu, hasierako para-&#13;</p><p class="Standard">metroen ordez iterazioko aldagaiak jarriz:&#13;</p><p class="Standard">bukbal(V, W ) ≡ hutsa_da?(V ) ∨ hutsa_da?(W )&#13;</p><p class="Standard">Iteraziotik aterako gara V edo W sekuentzia hutsa denean.&#13;</p><p class="Standard">7&#13;</p><p class="Standard">• Emaitza. Bukaera-baldintza bi kasuren disjuntzioa denez, kasu bakoitza-&#13;</p><p class="Standard">ren emaitza era banatuan kalkulatuko dugu. Inbariantean nahastu(V, W )&#13;</p><p class="Standard">adierazpenak duen balioa jarriko dugu kasu bakoitzean:&#13;</p><p class="Standard">hutsa_da?(V ) → nahastu(S, R) = U @nahastu(V, W ) = U @W&#13;</p><p class="Standard">hutsa_da?(W ) → nahastu(S, R) = U @nahastu(V, W ) = U @V&#13;</p><p class="Standard">Hau da, emaitza U @W edo U @V izango da, bukaerako kasuaren arabera:&#13;</p><p class="Standard">if hutsa_da?(V) then&#13;</p><p class="Standard">return U @ W;&#13;</p><p class="Standard">else&#13;</p><p class="Standard">return U @ V;&#13;</p><p class="Standard">end if;&#13;</p><p class="Standard">• Iterazioaren gorputza. Inbariantea abiapuntu hartuta, destolesketa / toles-&#13;</p><p class="Standard">keta teknika erabiliko dugu kasu induktibo bakoitzeko.&#13;</p><p class="Standard">Lehenengo kasu induktiboa: lehena(V ) ≤ lehena(W )&#13;</p><p class="Standard">nahastu(S, R)&#13;</p><p class="Standard">= U @ nahastu(V, W )&#13;</p><p class="Standard">destolestu&#13;</p><p class="Standard">= U @(lehena(V )@nahastu(hondarra(V ), W ))&#13;</p><p class="Standard">tolestu&#13;</p><p class="Standard">=(U @ lehena(V ) )@nahastu(hondarra(V ), W )&#13;</p><p class="Standard">U&#13;</p><p class="Standard">=&#13;</p><p class="Standard">@nahastu(&#13;</p><p class="Standard">V ,&#13;</p><p class="Standard">W )&#13;</p><p class="Standard">Hau da, lehenengo kasu induktiboan iterazioaren gorputza honako aldibe-&#13;</p><p class="Standard">reko asignazioa da:&#13;</p><p class="Standard">(U,V,W) := (U @ &lt; lehena(V) &gt;,hondarra(V),W);&#13;</p><p class="Standard">Aldibereko asignazio hau era bakar batean inplementa daiteke&#13;</p><p class="Standard">U := U @ &lt;lehena(V)&gt;;&#13;</p><p class="Standard">V := hondarra(V);&#13;</p><p class="Standard">Izan ere, lehenago V := hondarra(V ); jarriko bagenu, orduan V sekuentzian&#13;</p><p class="Standard">agertzen den lehenengo osagaia galdu egingo genuke.&#13;</p><p class="Standard">Bigarren kasu induktiboa: lehena(V ) &gt; lehena(W )&#13;</p><p class="Standard">nahastu(S, R)&#13;</p><p class="Standard">= U @ nahastu(V, W )&#13;</p><p class="Standard">destolestu&#13;</p><p class="Standard">= U @(lehena(W )@nahastu(V, hondarra(W )))&#13;</p><p class="Standard">tolestu&#13;</p><p class="Standard">=(U @ lehena(W ) )@nahastu( V, ,hondarra(W ))&#13;</p><p class="Standard">=&#13;</p><p class="Standard">U&#13;</p><p class="Standard">@nahastu( V ,&#13;</p><p class="Standard">Hortaz, aldibereko asignazioa honako hau da:&#13;</p><p class="Standard">8&#13;</p><p class="Standard">W )&#13;</p><p class="Standard">(U,V,W) := (U @ &lt;lehena(W)&gt;,V,hondarra(W));&#13;</p><p class="Standard">eta horrela inplementa daiteke:&#13;</p><p class="Standard">U := U @ &lt;lehena(W)&gt;;&#13;</p><p class="Standard">W := hondarra(W);&#13;</p><p class="Standard">Bi kasuak bilduta, iterazioaren gorputza horrela gelditzen da:&#13;</p><p class="Standard">if lehena(V) &lt;= lehena(W) then&#13;</p><p class="Standard">U := U @ &lt;lehena(V)&gt;;&#13;</p><p class="Standard">V := hondarra(V);&#13;</p><p class="Standard">else&#13;</p><p class="Standard">U := U @ &lt;lehena(W)&gt;;&#13;</p><p class="Standard">W := hondarra(W);&#13;</p><p class="Standard">end if;&#13;</p><p class="Standard">Lortu dugun funtzio iteratiboa honako hau da:&#13;</p><p class="Standard">function nahastu_it(S,R : sekuentzia(T)) return sekuentzia(T) is&#13;</p><p class="Standard">U,V,W : sekuentzia(T);&#13;</p><p class="Standard">begin&#13;</p><p class="Standard">U := &lt;&gt;;&#13;</p><p class="Standard">V := S;&#13;</p><p class="Standard">W := R;&#13;</p><p class="Standard">INB ≡ { nahastu(S, R) = U @nahastu(V, W ) }&#13;</p><p class="Standard">E ≡ luz(V)+luz(W)&#13;</p><p class="Standard">while not ( hutsa_da?(V) or hutsa_da?(W) ) loop&#13;</p><p class="Standard">if lehena(V) &lt;= lehena(W) then&#13;</p><p class="Standard">U := U @ &lt;lehena(V)&gt;;&#13;</p><p class="Standard">V := hondarra(V);&#13;</p><p class="Standard">else&#13;</p><p class="Standard">U := U @ &lt;lehena(W)&gt;;&#13;</p><p class="Standard">W := hondarra(W);&#13;</p><p class="Standard">end if;&#13;</p><p class="Standard">end loop;&#13;</p><p class="Standard">if hutsa_da?(V) then&#13;</p><p class="Standard">return U @ W;&#13;</p><p class="Standard">else&#13;</p><p class="Standard">return U @ V;&#13;</p><p class="Standard">end if;&#13;</p><p class="Standard">end nahastu_it;&#13;</p><p class="Standard">{ nahastu_it(S, R) = nahastu(S, R) }&#13;</p><p class="Standard">Hirugarren adibidea aztertuko dugu orain. Honako honetan errekurtsibitate aniz-&#13;</p><p class="Standard">koitzeko definizio induktibo bat transformatu, eta iteratibo bihurtuko dugu. Horreta-&#13;</p><p class="Standard">rako, destolestean dei bat baino gehiago eduki behar dira kontuan. Gainera, aztertu&#13;</p><p class="Standard">behar da zein dei-konbinazio destolestu behar den, gero tolestu ahal izateko.&#13;</p><p class="Standard">Izan bedi f ib funtzioa, non f ib(n) adierazpenak Fibonacci segidaren n-garren zen-&#13;</p><p class="Standard">bakia bueltatzen duen:&#13;</p><p class="Standard">9&#13;</p><p class="Standard">fib: Integer → Integer&#13;</p><p class="Standard">Aurre: n ≥ 0&#13;</p><p class="Standard">n&#13;</p><p class="Standard">baldin n ≤ 1&#13;</p><p class="Standard">f ib(n) =&#13;</p><p class="Standard">f ib(n − 1) + f ib(n − 2) bestela&#13;</p><p class="Standard">Funtzio honek kasu nabari bakar bat eta kasu induktibo bakar bat ditu, baina kasu&#13;</p><p class="Standard">induktiboan bi dei errekurtsibo erabiltzen dira.&#13;</p><p class="Standard">1. Aurreko adibideetan bezalaxe, destolesketa/tolesketa teknika erabiliko dugu erre-&#13;</p><p class="Standard">kurrentzi erlazioa ateratzeko, baina, kasu honetan, bi dira landu beharreko dei&#13;</p><p class="Standard">errekurtsiboak. Transformazioan estrategia hau erabiliko dugu: argumentu han-&#13;</p><p class="Standard">diena duen deia destolestu.&#13;</p><p class="Standard">f ib(5))&#13;</p><p class="Standard">destolestu&#13;</p><p class="Standard">= f ib(4) +f ib(3)&#13;</p><p class="Standard">destolestu&#13;</p><p class="Standard">= (f ib(3) + f ib(2)) + f ib(3)&#13;</p><p class="Standard">tolestu&#13;</p><p class="Standard">= 2 × f ib(3) +f ib(2)&#13;</p><p class="Standard">destolestu&#13;</p><p class="Standard">= 2 × (f ib(2) + f ib(1)) + f ib(2)&#13;</p><p class="Standard">tolestu&#13;</p><p class="Standard">= 3 × f ib(2) +2 × f ib(1)&#13;</p><p class="Standard">destolestu&#13;</p><p class="Standard">= 3 × (f ib(1) + f ib(0)) + 2 × f ib(1)&#13;</p><p class="Standard">tolestu&#13;</p><p class="Standard">= 5 × f ib(1) +3 × f ib(0)&#13;</p><p class="Standard">destolestu&#13;</p><p class="Standard">destolestu&#13;</p><p class="Standard">=5×1+3×0&#13;</p><p class="Standard">=5&#13;</p><p class="Standard">Transformazio horri erreparatuta, errekurrentzia-erlazio bat baino gehiago asma&#13;</p><p class="Standard">daiteke:&#13;</p><p class="Standard">(1) f ib(n) = x × f ib(u) + y × f ib(v)&#13;</p><p class="Standard">(2) f ib(n) = x × f ib(u) + y × f ib(u − 1)&#13;</p><p class="Standard">(3) f ib(n) = x × f ib(v + 1) + y × f ib(v)&#13;</p><p class="Standard">Azken errekurrentzia-erlazioa hartuko dugu inbariantetzat:&#13;</p><p class="Standard">IN B ≡ f ib(n) = x × f ib(v + 1) + y × f ib(v)&#13;</p><p class="Standard">Borne-adierazpena: E ≡ v&#13;</p><p class="Standard">10&#13;</p><p class="Standard">2. Inbariantea ardatz hartuta eratorriko ditugu programa iteratiboaren atal guztiak.&#13;</p><p class="Standard">• Hasieraketa. Inbariantea hasieran bete dadin, honako asignazio hauek erabil&#13;</p><p class="Standard">daitezke:&#13;</p><p class="Standard">x := 0;&#13;</p><p class="Standard">y := 1;&#13;</p><p class="Standard">v := n;&#13;</p><p class="Standard">• Bukaera-baldintza. Kasu nabari bakar bat dagoenez, bukaera-baldintza sin-&#13;</p><p class="Standard">plea da:&#13;</p><p class="Standard">bukbal(v) ≡ v = 0&#13;</p><p class="Standard">• Emaitza. Kasu nabaria v = 0 da. Inbariantean f ib(v + 1) eta f ib(v) adie-&#13;</p><p class="Standard">razpenak beren une horretako balioarekin ordezkatuko ditugu:&#13;</p><p class="Standard">v = 0 → f ib(n) = x × f ib(v + 1) + y × f ib(v) = x × 1 + y × 0 = x&#13;</p><p class="Standard">Hau da, emaitza x da:&#13;</p><p class="Standard">return x;&#13;</p><p class="Standard">• Iterazioaren gorputza. Inbariantea oinarritzat hartuta, destolesketa / toles-&#13;</p><p class="Standard">keta teknika erabiliko dugu:&#13;</p><p class="Standard">f ib(n)&#13;</p><p class="Standard">= x × f ib(v + 1) +y × f ib(v)&#13;</p><p class="Standard">destolestu&#13;</p><p class="Standard">= x × (f ib(v) + f ib(v − 1)) + y × f ib(v)&#13;</p><p class="Standard">tolestu&#13;</p><p class="Standard">=(x + y)×f ib(&#13;</p><p class="Standard">=&#13;</p><p class="Standard">x&#13;</p><p class="Standard">v&#13;</p><p class="Standard">)+ x ×f ib(v − 1)&#13;</p><p class="Standard">×f ib( v + 1 )+ y ×f ib( v )&#13;</p><p class="Standard">Hortaz, iterazioaren gorputza honako aldibereko asignazioa da:&#13;</p><p class="Standard">(x,y,v) := (x+y,x,v-1);&#13;</p><p class="Standard">Aldibereko asignazio hau inplementatzeko, aldagai laguntzaile bat erabili&#13;</p><p class="Standard">behar dugu:&#13;</p><p class="Standard">lag := x;&#13;</p><p class="Standard">x := x+y;&#13;</p><p class="Standard">y := lag;&#13;</p><p class="Standard">v := v-1;&#13;</p><p class="Standard">Horrenbestez, urrats guztiak bildurik, hona hemen lortu dugun funtzio iteratiboa:&#13;</p><p class="Standard">11&#13;</p><p class="Standard">function fib_it(n : Integer) return Integer is&#13;</p><p class="Standard">x,y,v,lag : Integer;&#13;</p><p class="Standard">begin&#13;</p><p class="Standard">{n≥0}&#13;</p><p class="Standard">x := 0;&#13;</p><p class="Standard">y := 1;&#13;</p><p class="Standard">v := n;&#13;</p><p class="Standard">INB ≡ { f ib(n) = x × f ib(v + 1) + y × f ib(v) }&#13;</p><p class="Standard">while not v = 0 loop&#13;</p><p class="Standard">E≡v&#13;</p><p class="Standard">lag := x;&#13;</p><p class="Standard">x := x+y;&#13;</p><p class="Standard">y := lag;&#13;</p><p class="Standard">v := v-1;&#13;</p><p class="Standard">end loop;&#13;</p><p class="Standard">return x;&#13;</p><p class="Standard">end fib_it;&#13;</p><p class="Standard">{ f ib_it(n) = f ib(n) }&#13;</p><p class="Standard">12&#13;</p></body></html>
